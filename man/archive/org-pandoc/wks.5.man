.\" Automatically generated by Pandoc 3.7.0.2
.\"
.TH "WKS" "5" "" ""
.SH NAME
wks \- A which\-key source file used by the \f[B]wk\f[R]​(1) program.
.SH DESCRIPTION
\f[B]wk\f[R]\(aqs configuration files use the \f[B]wks\f[R] syntax to
generate key chords.
.SH GRAMMAR RULES
The following are \f[I]ideally\f[R] the formal grammar rules for
\f[B]wks\f[R].
I have tried to note where behavior differs from the expectation.
If anything is not behaving as you expect, please see \f[B]CONTACT\f[R]
below to reach out.
.IP
.EX
key_chord          \-> ( chord | prefix | chord_array ) ;

chord              \-> trigger_key description keyword* command ;

prefix             \-> trigger_key description keyword* \(aq{\(aq ( key_chord )+ \(aq}\(aq ;

chord_array        \-> ( implicit_array | explicit_array ) ;

implicit_array     \-> modifier* \(aq...\(aq description keyword* command ;

explicit_array     \-> \(aq[\(aq ( trigger_key | chord_expression )+ \(aq]\(aq description keyword* command ;

chord_expression   \-> \(aq(\(aq trigger_key description keyword* command? \(aq)\(aq ;

trigger_key        \-> modifier* ( normal_key | special_key ) ;

normal_key         \-> ( \(aq\(rs\(rs\(aq [\(rs\(rs\(rs[\(rs]{}#\(dq:\(ha+()] | [\(ha\(rss\(rs[\(rs]{}#\(dq:\(ha+()] ) ;

special_key        \-> ( \(aqLeft\(aq    | \(aqRight\(aq   | \(aqUp\(aq     | \(aqDown\(aq
                      | \(aqTAB\(aq     | \(aqSPC\(aq     | \(aqRET\(aq    | \(aqDEL\(aq  | \(aqESC\(aq
                      | \(aqHome\(aq    | \(aqPgUp\(aq    | \(aqPgDown\(aq | \(aqEnd\(aq  | \(aqBegin\(aq
                      | \(aqVolDown\(aq | \(aqVolMute\(aq | \(aqVolUp\(aq  | \(aqPlay\(aq | \(aqStop\(aq
                      | \(aqPrev\(aq    | \(aqNext\(aq    | \(aqF\(aq[1\-35] ) \(rss+ ;

modifier           \-> ( \(aqC\(aq | \(aqH\(aq | \(aqM\(aq | \(aqS\(aq ) \(aq\-\(aq ;

description        \-> \(aq\(dq\(aq ( \(aq\(rs\(rs\(dq\(aq | [\(ha\(dq] | interpolation )* \(aq\(dq\(aq ;

command            \-> \(aq%\(aq delimiter ( . | interpolation )* delimiter ;

delimiter          \-> ( open_delim | close_delim | ([\(ha[{(])\(rs1 ) ;

open_delim         \-> ( \(aq{{\(aq | \(aq((\(aq | \(aq[[\(aq ) ;

close_delim        \-> ( \(aq}}\(aq | \(aq))\(aq | \(aq]]\(aq ) ;

interpolation      \-> \(aq%(\(aq identifier \(aq)\(aq ;

identifier         \-> ( \(aqkey\(aq
                      | \(aqindex\(aq
                      | \(aqindex+1\(aq
                      | \(aqdesc\(aq
                      | \(aqdesc\(ha\(aq
                      | \(aqdesc\(ha\(ha\(aq
                      | \(aqdesc,\(aq
                      | \(aqdesc,,\(aq
                      | \(aqwrap_cmd\(aq );

keyword            \-> ( hook | flag ) ;

hook               \-> \(aq\(ha\(aq ( \(aqbefore\(aq
                          | \(aqafter\(aq
                          | \(aqsync\-before\(aq
                          | \(aqsync\-after\(aq ) command ;

flag               \-> \(aq+\(aq ( \(aqkeep\(aq
                          | \(aqclose\(aq
                          | \(aqinherit\(aq
                          | \(aqignore\(aq
                          | \(aqignore\-sort\(aq
                          | \(aqunhook\(aq
                          | \(aqdeflag\(aq
                          | \(aqno\-before\(aq
                          | \(aqno\-after\(aq
                          | \(aqwrite\(aq
                          | \(aqexecute\(aq
                          | \(aqsync\-command\(aq
                          | \(aqunwrap\(aq
                          | \(aqwrap\(aq \(aq\(dq\(aq ( \(aq\(rs\(rs\(dq\(aq | [\(ha\(dq] | interpolation )* \(aq\(dq\(aq ) ;

preprocessor_macro \-> \(aq:\(aq ( string_macro
                          | switch_macro
                          | integer_macro
                          | unsigned_macro
                          | number_macro ) ;

string_macro       \-> ( \(aqinclude\(aq
                      | \(aqfg\(aq
                      | \(aqfg\-key\(aq
                      | \(aqfg\-delimiter\(aq
                      | \(aqfg\-prefix\(aq
                      | \(aqfg\-chord\(aq
                      | \(aqbg\(aq
                      | \(aqbd\(aq
                      | \(aqshell\(aq
                      | \(aqfont\(aq
                      | \(aqwrap\-cmd\(aq
                      | \(aqvar\(aq \(aq\(dq\(aq ( \(aq\(rs\(rs\(dq\(aq | [\(ha\(dq] )* \(aq\(dq\(aq ) \(aq\(dq\(aq ( \(aq\(rs\(rs\(dq\(aq | [\(ha\(dq] )* \(aq\(dq\(aq ;

switch_macro       \-> ( \(aqdebug\(aq
                      | \(aqsort\(aq
                      | \(aqtop\(aq
                      | \(aqbottom\(aq );

integer_macro      \-> ( \(aqmenu\-width\(aq
                      | \(aqmenu\-gap\(aq ) \(aq\-\(aq? [0\-9]+ ;

unsigned_macro     \-> ( \(aqmax\-columns\(aq
                      | \(aqborder\-width\(aq
                      | \(aqwidth\-padding\(aq
                      | \(aqheight\-padding\(aq
                      | \(aqdelay\(aq ) [0\-9]+ ;

number_macro       \-> ( \(aqborder\-radius\(aq ) \(aq\-\(aq? [0\-9]+ ( \(aq.\(aq [0\-9]* )? ;
.EE
.PP
\f[B]NOTE\f[R] in \f[I]wks\f[R] files, comments can be added using the
pound character (\f[I]#\f[R]).
When a pound character is encountered, it signifies the start of a
comment.
The comment extends from the pound character until the end of the line.
It\(aqs important to note that the pound character is treated as a
literal character within \f[I]descriptions\f[R] and \f[I]commands\f[R]
and does not indicate the start of a comment in those contexts.
.SS KEY CHORD
A \f[I]key chord\f[R] is the top\-level construct in the grammar and
represents a complete key chord definition.
.IP
.EX
key_chord \-> ( chord | prefix | chord_array ) ;
.EE
.PP
It can be either a \f[I]prefix\f[R], a \f[I]chord\f[R], or a \f[I]chord
array\f[R].
.SS CHORD
A \f[I]chord\f[R] is a \f[I]key chord\f[R] that results in \f[B]wk\f[R]
performing some action, like executing a command, when the trigger key
is pressed.
.IP
.EX
chord \-> trigger_key description keyword* command ;
.EE
.PP
All chords must have a \f[I]trigger key\f[R], \f[I]description\f[R], and
a \f[I]command\f[R].
Zero or more \f[I]keywords\f[R] may be given between the
\f[I]description\f[R] and \f[I]command\f[R].
.SS TRIGGER KEY
A \f[I]trigger key\f[R] represents the specific keypress or key
combination that triggers a corresponding action or command.
In a \f[I]wks\f[R] file, it is the written representation of the
physical key(s) pressed by the user on their keyboard.
.IP
.EX
trigger_key \-> modifier* ( normal_key | special_key ) ;
.EE
.PP
A \f[I]trigger key\f[R] is then zero or more \f[I]modifiers\f[R]
followed by a \f[I]normal key\f[R] or a \f[I]special key\f[R].
.SS NORMAL KEY
A \f[I]normal key\f[R] is any printable, non\-whitespace, utf8
character.
.IP
.EX
normal_key \-> ( \(aq\(rs\(rs\(aq [\(rs\(rs\(rs[\(rs]{}#\(dq:\(ha+()] | [\(ha\(rss\(rs[\(rs]{}#\(dq:\(ha+()] ) ;
.EE
.PP
Certain characters have special meanings in \f[I]wks\f[R] files.
To use these characters as a normal key, simply precede them with a
backslash (\f[I]\(rs\f[R]).
.RS
.TP
\f[B][\f[R]
Begins a \f[I]chord array\f[R].
.TP
\f[B]]\f[R]
Ends a \f[I]chord array\f[R].
.TP
\f[B]{\f[R]
Begins a \f[I]prefix\f[R] block.
.TP
\f[B]}\f[R]
Ends a \f[I]prefix\f[R] block.
.TP
\f[B]#\f[R]
Begins a comment.
.TP
\f[B]\(dq\f[R]
Begins and ends a \f[I]description\f[R].
.TP
\f[B]:\f[R]
Begins a \f[I]preprocessor macro\f[R].
.TP
*^*^
Begins a \f[I]hook\f[R].
.TP
\f[B]+\f[R]
Begins a \f[I]flag\f[R].
.TP
\f[B](\f[R]
Begins a \f[I]chord expression\f[R].
.TP
\f[B])\f[R]
Ends a \f[I]chord expression\f[R].
.RE
.PP
All other non\-whitespace, printable utf8 characters prior to a
description will be interpreted as a normal key.
Those that are whitespace or non\-printable fall into the special key
category.
.SS SPECIAL KEY
Special keys like \f[I]tab\f[R], \f[I]escape\f[R], \f[I]spacebar\f[R],
and \f[I]F1\f[R] can still be used as trigger keys in \f[I]wks\f[R]
files via their special forms.
.IP
.EX
special_key \-> ( \(aqLeft\(aq    | \(aqRight\(aq   | \(aqUp\(aq     | \(aqDown\(aq
               | \(aqTAB\(aq     | \(aqSPC\(aq     | \(aqRET\(aq    | \(aqDEL\(aq  | \(aqESC\(aq
               | \(aqHome\(aq    | \(aqPgUp\(aq    | \(aqPgDown\(aq | \(aqEnd\(aq  | \(aqBegin\(aq
               | \(aqVolDown\(aq | \(aqVolMute\(aq | \(aqVolUp\(aq  | \(aqPlay\(aq | \(aqStop\(aq
               | \(aqPrev\(aq    | \(aqNext\(aq    | \(aqF\(aq[1\-35] ) \(rss+ ;
.EE
.PP
Each form should indicate the special key it represents but here is a
chart to make things explicit.
.RS
.TP
\f[B]Left\f[R]
Left arrow
.TP
\f[B]Right\f[R]
Right arrow
.TP
\f[B]Up\f[R]
Up arrow
.TP
\f[B]Down\f[R]
Down arrow
.TP
\f[B]TAB\f[R]
Tab
.TP
\f[B]SPC\f[R]
Space
.TP
\f[B]RET\f[R]
Enter/Return
.TP
\f[B]DEL\f[R]
Delete
.TP
\f[B]ESC\f[R]
Esc
.TP
\f[B]Home\f[R]
Home
.TP
\f[B]PgUp\f[R]
Page up
.TP
\f[B]PgDown\f[R]
Page down
.TP
\f[B]End\f[R]
End
.TP
\f[B]Begin\f[R]
Begin
.TP
\f[B]F[1\-35]\f[R]
Function keys 1 through 35.
.TP
\f[B]VolDown\f[R]
Volume Down
.TP
\f[B]VolMute\f[R]
Mute Vol
.TP
\f[B]VolUp\f[R]
Volume Up
.TP
\f[B]Play\f[R]
Play Audio
.TP
\f[B]Stop\f[R]
Stop Audio
.TP
\f[B]Prev\f[R]
Audio Previous
.TP
\f[B]Next\f[R]
Audio Next
.RE
.PP
In \f[I]wks\f[R] files, whitespace is generally not significant around
individual parts of the syntax, with one notable exception: \f[I]special
keys\f[R].
When using \f[I]special keys\f[R], it is required to include whitespace
between the end of the special key and the start of the next item in the
\f[I]wks\f[R] file.
.PP
If you have any additional special keys that you would like
\f[I]wks\f[R] files to support, please open an issue or a pull request.
.SS MODIFIER
As mentioned above, zero or more \f[I]modifiers\f[R] can be given in a
\f[I]trigger key\f[R].
.IP
.EX
modifier \-> ( \(aqC\(aq | \(aqH\(aq | \(aqM\(aq | \(aqS\(aq ) \(aq\-\(aq ;
.EE
.PP
Modifiers can be used in \f[I]wks\f[R] files via their special forms.
.RS
.TP
\f[B]C\-\f[R]
\f[I]Control\f[R] key
.TP
\f[B]H\-\f[R]
\f[I]Hyper\f[R] key
.TP
\f[B]M\-\f[R]
\f[I]Meta\f[R] key
.TP
\f[B]S\-\f[R]
\f[I]Shift\f[R] key
.RE
.PP
Modifiers act as one would expect.
To match the keypress \f[I]Control+c\f[R] use the form \f[I]C\-c\f[R] in
your \f[I]wks\f[R] file.
.PP
Among the modifiers, the Shift modifier (\f[I]S\-\f[R]) has a unique
behavior when used with \f[I]normal keys\f[R].
Due to the way normal keys are interpreted, the \f[I]S\-\f[R] modifier
is not always necessary.
To determine whether \f[I]S\-\f[R] is required, it is recommended to
test the character in a \f[I]wks\f[R] file by typing it with and without
the Shift key pressed.
.PP
If the character is non\-whitespace, printable, and the shifted and
unshifted versions produce different output, then the \f[I]S\-\f[R]
modifier is not needed.
For instance, pressing the \f[I]a\f[R] key with the Shift key held down
produces an uppercase \f[I]A\f[R].
This test demonstrates that the key\(aqs output changes based on the
Shift key state.
.PP
In such cases, using \f[I]S\-a\f[R] in a \f[I]wks\f[R] file would not
work as expected because the key will never match when the user presses
\f[I]Shift+a\f[R].
.PP
I am open to changing it so that \f[I]S\-a\f[R] and \f[I]A\f[R] match
the same \f[I]Shift+a\f[R] keypress, but I have yet to find a fitting
solution.
The ones I can think of either involve depending on some utf8 library,
writing the code by hand, or permitting this syntax for ASCII but not
other character sets.
Each has its own drawback, and I find the current solution to be
intuitive in practice.
.SS DESCRIPTION
A \f[I]description\f[R] provide a hint about the purpose of the
\f[I]chord\f[R] or \f[I]prefix\f[R].
.IP
.EX
description \-> \(aq\(dq\(aq ( \(aq\(rs\(rs\(dq\(aq | [\(ha\(dq] | interpolation )* \(aq\(dq\(aq ;
.EE
.PP
A \f[I]description\f[R] starts with a double quote (\f[I]\(dq\f[R]),
followed by zero or more of the following:
.RS
.TP
\f[B]\(rs\(dq\f[R]
Escaped double quotes.
.TP
\f[B][\(ha\(dq]\f[R]
Any non\-double quote character.
.TP
\f[B]interpolation\f[R]
An interpolation.
.RE
.PP
A \f[I]description\f[R] ends with a double quote.
Aside from \f[I]interpolations\f[R], a \f[I]description\f[R] looks like
your typical string in many programming languages.
.SS COMMAND
A \f[I]command\f[R] is some action to be executed upon completing a
\f[I]key chord\f[R] sequence.
.IP
.EX
command \-> \(aq%\(aq delimiter ( . | interpolation )* delimiter ;
.EE
.PP
A \f[I]command\f[R] begins with the percent character (\f[I]%\f[R])
followed by a \f[I]delimiter\f[R].
After the \f[I]delimiter\f[R] zero or more characters, or
\f[I]interpolations\f[R] may be given.
A \f[I]command\f[R] is ended with the same delimiter that followed the
percent character.
.PP
Because the \f[I]delimiter\f[R] is user defined, there should be no
misinterpretation of anything between the delimiters.
This means any command given at the command\-line should be right at
home in between the delimiters.
.SS DELIMITER
A \f[I]delimiter\f[R] acts as a start and stop marker for a
\f[I]command\f[R] in a \f[I]wks\f[R] file.
.IP
.EX
delimiter   \-> ( open_delim | close_delim | ([\(ha[{(])\(rs1 )  ;

open_delim  \-> ( \(aq{{\(aq | \(aq((\(aq | \(aq[[\(aq ) ;

close_delim \-> ( \(aq}}\(aq | \(aq))\(aq | \(aq]]\(aq ) ;
.EE
.PP
A \f[I]delimiter\f[R] may be one of the following:
.RS
.TP
\f[B]open~delim~\f[R] or \f[B]close~delim~\f[R]
The opening and closing delimiters are special delimiters that that have
an inverse match.
If an opening delimiter is given then the corresponding closing
delimiter is required to end the command (e.g., \f[I]{{\f[R] matches
\f[I]}}\f[R] and so forth).
.TP
\f[B]([\(ha[{(])\(rs1\f[R]
Any \f[B]ASCII\f[R] character that is not any opening bracket
(\f[I][\f[R]), opening brace (\f[I]{\f[R]), or any opening parenthesis
(\f[I](\f[R]), given twice.
\f[B]NOTE\f[R] this excludes null bytes (\f[I]\(rs0\f[R]) as these will
indicate the end of a \f[I]wks\f[R] file or script.
When an arbitrary delimiter is given the same character is expected to
be repeated to indicate the end of a command.
.RE
.PP
The \f[I]delimiter\f[R] from one \f[I]command\f[R] to the next may be
completely different.
This puts the burden on the user to ensure their \f[I]delimiter\f[R] is
compatible with the content of the command.
.PP
Here are some examples of different delimiters for the same command.
.IP
.EX
# Commands with opening and closing delimiters
%{{echo \(dqhello, world\(dq}}
%((echo \(dqhello, world\(dq))
%[[echo \(dqhello, world\(dq]]

# Valid arbitrary delimiters
%||echo \(dqhello, world\(dq||
%%%echo \(dqhello, world\(dq%%
%zzecho \(dqhello, world\(dqzz
.EE
.PP
Inspired by \f[B]sed\f[R]​(1), this should keep \f[I]wks\f[R] syntax
compatible with shell commands, almost indefinitely.
It also makes it possible to nest a \f[I]wks\f[R] script within a
\f[I]wks\f[R] command if you want to get really weird.
.SS PREFIX
A \f[I]prefix\f[R] is a special type of \f[I]key chord\f[R] that acts as
a container for other \f[I]key chords\f[R].
It represents an incomplete key combination that does not trigger a
\f[I]command\f[R] on its own.
.IP
.EX
prefix \-> trigger_key description keyword* \(aq{\(aq ( key_chord )+ \(aq}\(aq ;
.EE
.PP
A \f[I]prefix\f[R] has many of the same components as a \f[I]chord\f[R].
It begins with a \f[I]trigger key\f[R], followed by a
\f[I]description\f[R], zero or more \f[I]keywords\f[R] and then a block
of one or more \f[I]key chords\f[R] surrounded by an opening and closing
brace (\f[I]{\f[R], and \f[I]}\f[R]).
.PP
\f[B]Note\f[R] that a key chord may be a \f[I]prefix\f[R], a
\f[I]chord\f[R], or a \f[I]chord array\f[R], meaning many prefixes can
be nested one inside another.
.PP
Here is a simple example of a prefix:
.IP
.EX
m \(dq+Music\(dq
{
    n \(dqNext\(dq %{{mpc next}}
    p \(dqPrev\(dq %{{mpc prev}}
}
.EE
.SS CHORD ARRAY
\f[I]Chords\f[R] and \f[I]prefixes\f[R] are standard fare in the realm
of key chords, so what the heck is a \f[I]chord array\f[R]?
Well, mostly syntactic sugar so you do not have to repeat yourself when
it comes to \f[I]chords\f[R] that are very similar but only differ in
slightly different ways.
.IP
.EX
chord_array \-> ( implicit_array | explicit_array ) ;
.EE
.PP
A \f[I]chord array\f[R] comes in two flavors, \f[I]implicit\f[R] and
\f[I]explicit\f[R].
.SS IMPLICIT ARRAY
An \f[I]implicit array\f[R] is the simplest of the two flavors.
It utilizes the \f[I]implicitArrayKeys\f[R] variable defined in
\f[I]config.def.h\f[R] to generate \f[I]chords\f[R] from these
\f[I]trigger keys\f[R].
.IP
.EX
implicit_array \-> modifier* \(aq...\(aq description keyword* command ;
.EE
.PP
An \f[I]implicit array\f[R] is then zero or more modifiers, an ellipsis
(\f[I]\&...\f[R]), a description, zero or more keywords, and a command.
This is practially a \f[I]chord\f[R] in terms of its form, but in
behavior an \f[I]implicit array\f[R] generates any number of
\f[I]chords\f[R] from this simple syntax.
.PP
As an example, say your implicit array keys are set to \f[I]h\f[R],
\f[I]j\f[R], \f[I]k\f[R], and \f[I]l\f[R], and you have this
\f[I]wks\f[R] file:
.IP
.EX
\&... \(dqSwitch workspace %(index+1)\(dq %{{xdotool set_desktop %(index)}}
.EE
.PP
This is the equivilant \f[I]wks\f[R] file without the use of an
\f[I]implicit array\f[R]:
.IP
.EX
h \(dqSwitch workspace 1\(dq %{{xdotool set_desktop 0}}
j \(dqSwitch workspace 2\(dq %{{xdotool set_desktop 1}}
k \(dqSwitch workspace 3\(dq %{{xdotool set_desktop 2}}
l \(dqSwitch workspace 4\(dq %{{xdotool set_desktop 3}}
.EE
.SS EXPLICIT ARRAY
An \f[I]explicit array\f[R] is most useful when the desired
\f[I]chords\f[R] are less homogeneous.
.IP
.EX
explicit_array \-> \(aq[\(aq ( trigger_key | chord_expression )+ \(aq]\(aq description keyword* command ;
.EE
.PP
To use an \f[I]explicit array\f[R] begin with an open bracket
(\f[I][\f[R]) followed by one or more \f[I]trigger keys\f[R] or
\f[I]chord expressions\f[R].
The array portion ends with a closing bracket (\f[I]]\f[R]) followed by
the standard chord components, a description, zero or more keywords, and
a command.
.PP
I think an example will make things clear:
.IP
.EX
# Chord array version
[asdfghjkl] \(dqSwitch workspace %(index+1)\(dq %{{xdotool set_desktop %(index)}}

# Individual chords and no interpolation
a \(dqSwitch workspace 1\(dq %{{xdotool set_desktop 0}}
s \(dqSwitch workspace 2\(dq %{{xdotool set_desktop 1}}
d \(dqSwitch workspace 3\(dq %{{xdotool set_desktop 2}}
f \(dqSwitch workspace 4\(dq %{{xdotool set_desktop 3}}
g \(dqSwitch workspace 5\(dq %{{xdotool set_desktop 4}}
h \(dqSwitch workspace 6\(dq %{{xdotool set_desktop 5}}
j \(dqSwitch workspace 7\(dq %{{xdotool set_desktop 6}}
k \(dqSwitch workspace 8\(dq %{{xdotool set_desktop 7}}
l \(dqSwitch workspace 9\(dq %{{xdotool set_desktop 8}}
.EE
.PP
In this case, \f[I]explicit arrays\f[R] are only slightly different than
an \f[I]implicit array\f[R].
However, \f[I]explicit arrays\f[R] support \f[I]chord expressions\f[R]
which make them far more flexible.
.SS CHORD EXPRESSION
Explicit arrays can be very simple with each \f[I]chord\f[R] being only
slightly different from one another.
However, it may make sense to include chords that mostly fit into the
\f[I]explicit array\f[R] with some more distinct differences.
For this situation, \f[I]chord expressions\f[R] may be the answer.
.IP
.EX
chord_expression \-> \(aq(\(aq trigger_key description keyword* command? \(aq)\(aq ;
.EE
.PP
A \f[I]chord expression\f[R] is only valid within a \f[I]chord
array\f[R], and it is essentially a \f[I]chord\f[R] wrapped in
parentheses with some added flexibility.
Normally, a \f[I]chord\f[R] requires at least a \f[I]trigger key\f[R], a
\f[I]description\f[R], and a \f[I]command\f[R].
A \f[I]chord expression\f[R], on the other hand, requires only a
\f[I]trigger key\f[R] and a \f[I]description\f[R].
Any other information will be filled in by the surrounding \f[I]chord
array\f[R].
.PP
Here is an example of a chord expression within a \f[I]chord array\f[R]:
.IP
.EX
# With chord arrays and chord expressions
[
    (b \(dqBrave\(dq)
    (c \(dqMullvad Chrome\(dq %{{mullvad\-exclude chrome \(ti/startpage.html}})
    x
] \(dqXDG\-OPEN\(dq %{{%(desc,,) \(ti/startpage.html}}

# With chords and no interpolation
b \(dqBrave\(dq %{{brave \(ti/startpage.html}}
c \(dqMullvad Chrome\(dq %{{mullvad\-exclude chrome \(ti/startpage.html}}
x \(dqXDG\-OPEN\(dq %{{xdg\-open \(ti/startpage.html}}
.EE
.PP
Admittedly, \f[I]chord expressions\f[R] may not be that useful but they
were easy to implement so they are here for those who want to use them.
.SS INTERPOLATION
An \f[I]interpolation\f[R] is a means of accessing some metadata of the
current \f[I]chord\f[R] from within a \f[I]description\f[R] or a
\f[I]command\f[R].
.IP
.EX
interpolation \-> \(aq%(\(aq identifier \(aq)\(aq ;
.EE
.PP
The basic syntax for an \f[I]interpolation\f[R] begins with a
\f[I]%(\f[R] delimiter followed by an \f[I]identifier\f[R] and closing
parenthesis (\f[I])\f[R]).
.SS IDENTIFIER
The following identifiers are valid within an \f[I]interpolation\f[R]:
.RS
.TP
\f[B]key\f[R]
The \f[I]key\f[R] \f[I]identifier\f[R] corresponds to the \f[I]trigger
key\f[R] of the current \f[I]chord\f[R].
This makes the most sense to use within a \f[I]chord array\f[R] or for a
\f[I]chord\f[R] that may change frequently or is not know ahead of time.
.TP
\f[B]index\f[R]
The \f[I]index\f[R] \f[I]identifier\f[R] corresponds to the 0 base index
of the current \f[I]chord\f[R] or \f[I]prefix\f[R] within the current
scope.
\f[B]NOTE\f[R] a \f[I]prefix\f[R] starts a new scope.
.TP
\f[B]index+1\f[R]
The \f[I]index+1\f[R] \f[I]identifier\f[R] corresponds to the 1 base
index of the current \f[I]chord\f[R] or \f[I]prefix\f[R] within the
current scope.
\f[B]NOTE\f[R] a \f[I]prefix\f[R] starts a new scope.
.TP
\f[B]desc\f[R]
The \f[I]desc\f[R] \f[I]identifier\f[R] correspond to the
\f[I]description\f[R] of the current \f[I]chord\f[R] or
\f[I]prefix\f[R].
The \f[I]desc\f[R] \f[I]identifier\f[R] may not be given within a
\f[I]description\f[R].
An error will be thrown in the case where this is attempted.
.TP
*desc^*^
The \f[I]description\f[R] of the current \f[I]chord\f[R] with the
\f[B]first\f[R] character capitalized.
.TP
*desc\(ha^*^
The \f[I]description\f[R] of the current \f[I]chord\f[R] with the
\f[B]all\f[R] characters capitalized.
.TP
\f[B]desc,\f[R]
The \f[I]description\f[R] of the current \f[I]chord\f[R] with the
\f[B]first\f[R] character downcased.
.TP
\f[B]desc,,\f[R]
The \f[I]description\f[R] of the current \f[I]chord\f[R] with the
\f[B]all\f[R] characters downcased.
.TP
\f[I]unwrap\f[R]
Prevent wrapping this chord, even if a global wrapper is set or
inherited from a parent prefix.
.TP
wrap~cmd~
The value of the global wrapper command.
This is defined by the \f[I]:wrap\-cmd\f[R] preprocessor macro, the
\f[I]\(enwrap\-cmd\f[R] cli flag, or defined by \f[I]wrapperCmd\f[R] in
your \f[I]config.[def.]h\f[R] file.
.RE
.SS KEYWORD
A \f[I]keyword\f[R] is an optional instruction to modify the behavior of
a \f[I]chord\f[R] or \f[I]prefix\f[R].
.IP
.EX
keyword \-> ( hook | flag ) ;
.EE
.PP
A \f[I]keyword\f[R] is either a \f[I]hook\f[R] or a \f[I]flag\f[R].
Both have equal precedence, meaning they can be mixed up wherever they
are permitted.
.SS HOOK
Hooks provide means of adding additional commands to a chord or prefix.
.IP
.EX
hook \-> \(aq\(ha\(aq ( \(aqbefore\(aq
            | \(aqafter\(aq
            | \(aqsync\-before\(aq
            | \(aqsync\-after\(aq ) command ;
.EE
.PP
A \f[I]hook\f[R] begins with the caret character (\f[I]\(ha\f[R]),
followed by the type of \f[I]hook\f[R], and finally the command the
\f[I]hook\f[R] will run.
.PP
The \f[I]hook\f[R] type has to do with the order the command will be
run.
The \f[I]before\f[R] hooks run before the chord\(aqs command, and the
\f[I]after\f[R] hooks run after the chord\(aqs command.
.PP
The \f[I]sync\-\f[R] hooks relate to how \f[B]wk\f[R] runs the commands.
By default, all commands are run asynchronously to prevent a command
from blocking \f[B]wk\f[R].
However, if the hook must complete before \f[B]wk\f[R] can proceed you
can use the \f[I]sync\-*\f[R] variant to enforce this behavior.
.PP
\f[B]NOTE\f[R] that a blocking command may prevent \f[B]wk\f[R] from
ever resuming execution.
In the event that this happens, users may need to restart their system
entirely to regain control of their keyboard.
.PP
See \f[B]EXAMPLES\f[R] for further discussion about hooks.
.SS FLAG
Flags are similar to command\-line flags in that they change the
behavior of \f[B]wk\f[R].
.IP
.EX
flag \-> \(aq+\(aq ( \(aqkeep\(aq
            | \(aqclose\(aq
            | \(aqinherit\(aq
            | \(aqignore\(aq
            | \(aqignore\-sort\(aq
            | \(aqunhook\(aq
            | \(aqdeflag\(aq
            | \(aqno\-before\(aq
            | \(aqno\-after\(aq
            | \(aqwrite\(aq
            | \(aqexecute\(aq
            | \(aqsync\-command\(aq
            | \(aqunwrap\(aq
            | \(aqwrap\(aq \(aq\(dq\(aq ( \(aq\(rs\(rs\(dq\(aq | [\(ha\(dq] | interpolation )* \(aq\(dq\(aq ) ;
.EE
.PP
Flags begin with a plus character (\f[I]+\f[R]), followed by the flag
itself.
Here is how each flag changes the behavior of \f[B]wk\f[R]:
.RS
.TP
\f[I]keep\f[R]
Instead of closing after \f[B]wk\f[R] finds a matching chord, it keeps
the \f[B]wk\f[R] menu open.
.TP
\f[I]close\f[R]
Forces the \f[B]wk\f[R] window to close.
Useful when \f[I]+keep\f[R] was given to a surrounding prefix.
.TP
\f[I]inherit\f[R]
Causes the prefix to inherit flags and hooks from its parent.
Has no effect when given to a chord.
.TP
\f[I]ignore\f[R]
Ignore all hooks and flags from the surrounding prefix.
Has no effect when given to a prefix.
.TP
\f[I]ignore\-sort\f[R]
Chord is ignored during sorting leaving it in it in the same position it
was parsed in.
.TP
\f[I]unhook\f[R]
Ignore all hooks from the surrounding prefix.
.TP
\f[I]deflag\f[R]
Ignore all flags from the surrounding prefix.
.TP
\f[I]no\-before\f[R]
Ignore \f[I]before\f[R] and \f[I]sync\-before\f[R] hooks from the
surrounding prefix.
.TP
\f[I]no\-after\f[R]
Ignore \f[I]after\f[R] and \f[I]sync\-after\f[R] hooks from the
surrounding prefix.
.TP
\f[I]write\f[R]
Write commands to stdout rather than executing them.
.TP
\f[I]execute\f[R]
Execute the command rather than writing them to stdout.
Useful when \f[I]+write\f[R] was given to a surrounding prefix.
.TP
\f[I]sync\-command\f[R]
Execute the command in a blocking fashion.
See the note in \f[B]HOOK\f[R] regarding potential issues with blocking
commands.
.TP
\f[I]wrap\f[R] \(aq\(dq\(aq ( \(aq\(rs\(rs\(dq\(aq | [\(ha\(dq] | interpolation )* \(aq\(dq\(aq
When given to a \f[I]prefix\f[R], wrap chord commands with the argument.
Can be given to a \f[I]chord\f[R], or \f[I]chord\-array\f[R] to wrap the
immediate command(s).
The argument is a string that supports interpolation, the same syntax as
a \f[I]description\f[R].
The \(dqwrapper\(dq is applied as \f[I]/bin/sh \-c WRAPPER CMD\f[R].
See \f[B]EXAMPLES\f[R] for scenarios where this is useful.
.RE
.PP
See \f[B]EXAMPLES\f[R] for further discussion about flags.
.SS PREPROCESSOR MACROS
There are a number of preprocessor macros that can be used in
\f[I]wks\f[R] files.
These have a number of uses from making \f[I]wks\f[R] files more modular
to controlling the look and feel of \f[B]wk\f[R]​(1).
.IP
.EX
preprocessor_macro \-> \(aq:\(aq ( string_macro
                          | switch_macro
                          | integer_macro
                          | unsigned_macro
                          | number_macro ) ;
.EE
.PP
A preprocessor macro begins with the colon character (\f[I]:\f[R])
followed by a specific macro form.
.PP
The majority of macros correspond to the command\-line arguments that
\f[B]wk\f[R]​(1) supports.
When given, these override anything given at the command\-line.
They are here to provide a baked\-in alternative to the command\-line
versions making it easy to simply run the \f[I]wks\f[R] file and get the
desired look and feel without having to give the same arguments each
time.
It can also help distinguish the purpose of the key chords if it is
intended to be used as part of a script by making the \f[B]wk\f[R]​(1)
popup window different from the builtin settings.
.SS STRING MACROS
String macros require a string argument.
.IP
.EX
string_macro \-> ( \(aqinclude\(aq
                | \(aqfg\-color\(aq
                | \(aqbg\-color\(aq
                | \(aqbd\-color\(aq
                | \(aqshell\(aq
                | \(aqfont\(aq
                | \(aqwrap\-cmd\(aq
                | \(aqvar\(aq \(aq\(dq\(aq ( \(aq\(rs\(rs\(dq\(aq | [\(ha\(dq] )* \(aq\(dq\(aq ) \(aq\(dq\(aq ( \(aq\(rs\(rs\(dq\(aq | [\(ha\(dq] )* \(aq\(dq\(aq ;
.EE
.PP
Many of the macros here work the same as their command\-line
counterparts.
Simply use \f[B]:MACRO \(dqARGUMENT\(dq\f[R] to make use of any string
macro, (e.g.
\f[B]:shell \(dq/usr/bin/env zsh\(dq\f[R]).
.SS INCLUDE MACRO
The \f[I]:include\f[R] macro is not present as a command\-line argument
to \f[B]wk\f[R]​(1).
This is because this macro has more to do with \f[I]wks\f[R] files than
the look and feel of \f[B]wk\f[R]​(1).
The \f[I]:include\f[R] macro works similarly to the \f[I]#include\f[R]
macro found in C/C++.
It allows users to bring other \f[I]wks\f[R] files into a single file.
\f[B]NOTE\f[R], self includes and recursive includes are not permitted
and will cause an error.
\f[B]NOTE\f[R], the same file may be included multiple times.
This is not an error, and may even be desirable for some users.
\f[B]NOTE\f[R], while the \f[I]#include\f[R] macro in C/C++ has
restrictions on where it can go in a file, the \f[I]:include\f[R] macro
in a \f[I]wks\f[R] file may go literally anywhere.
As for file resolution, it\(aqs pretty simple.
A relative path is assumed to be in the same directory as the file being
processed, and absolute paths are just that, absolute.
.PP
See \f[B]EXAMPLES\f[R] for a full demonstration of the
\f[I]:include\f[R] macro.
.SS VAR MACRO
The \f[I]:var\f[R] macro allows you to define a variable with some
value.
It takes two arguments, the first is the \f[I]key\f[R] or \f[I]variable
name\f[R], and the second is the \f[I]value\f[R] which can be an empty
string, i.e., unset a previously defined \f[I]var\f[R].
The \f[I]value\f[R] of any \f[I]var\f[R] can be accessed through
interpolation by using the corresponding \f[I]key\f[R].
The \f[I]key\f[R] can contain any character except a closing parenthesis
(\(aq\f[I])\f[R]\(aq), otherwise it would be inaccessible through
interpolation.
The \f[I]key\f[R] cannot shadow builtin interpolations.
.PP
See \f[B]EXAMPLES\f[R] for a demonstration.
.SS SWITCH MACROS
Switch macros are the simplest of the bunch.
They are essentially an on switch for the corresponding menu settings.
.IP
.EX
switch_macro \-> ( \(aqdebug\(aq
                | \(aqsort\(aq
                | \(aqtop\(aq
                | \(aqbottom\(aq );
.EE
.PP
All the switch macros correspond to their cli flags for \f[B]wk\f[R]​(1).
.SS INTEGER MACROS
The integer macros require a positive or negative integer argument to
the macro.
.IP
.EX
integer_macro \-> ( \(aqmenu\-width\(aq
                 | \(aqmenu\-gap\(aq ) \(aq\-\(aq? [0\-9]+ ;
.EE
.PP
All the integer macros correspond to their cli flags for
\f[B]wk\f[R]​(1).
.SS UNSIGNED MACROS
The unsigned macros require a positive integer argument to the macro.
.IP
.EX
unsigned_macro \-> ( \(aqmax\-columns\(aq
                  | \(aqborder\-width\(aq
                  | \(aqwidth\-padding\(aq
                  | \(aqheight\-padding\(aq
                  | \(aqdelay\(aq ) [0\-9]+ ;
.EE
.PP
All the unsigned macros correspond to their cli flags for
\f[B]wk\f[R]​(1).
.SS NUMBER MACROS
The number macros require a positive number argument to the macro.
.IP
.EX
number_macro \-> ( \(aqborder\-radius\(aq ) \(aq\-\(aq? [0\-9]+ ( \(aq.\(aq [0\-9]* )? ;
.EE
.PP
All the number macros correspond to their cli flags for \f[B]wk\f[R]​(1).
.SH EXAMPLES
.SS HOOKS
Users can certainly chain commands together the same way one would chain
commands in a regular shell, but hooks help to reduce repetition.
They also make more sense in the context of prefixes.
.IP
.EX
# With hooked prefix
e \(dq+Emacs\(dq \(habefore %{{xdotool set_desktop 1}}
{
    o \(dqOpen\(dq %{{emacsclient \-c \-a \(dq\(dq}}
    r \(dqRoam\(dq %{{emacsclient \-c \-a \(dq\(dq \(ti/20240101080032\-startpage.org}}
}

# Without hooks
e \(dq+Emacs\(dq
{
    o \(dqOpen\(dq %{{xdotool set_desktop 1 ; emacsclient \-c \-a \(dq\(dq}}
    r \(dqRoam\(dq %{{xdotool set_desktop 1 ; emacsclient \-c \-a \(dq\(dq \(ti/20240101080032\-startpage.org}}
}
.EE
.PP
As you can see, this helps to cut down on repetition, but it also helps
enforce a workflow rule without the need to setup desktop environment
rules and such.
.PP
This example also hints at the idea of inheritance as the hook was given
to a prefix and not to individual chords.
This topic is covered after introducing flags as these also factor into
the discussion.
.SS FLAGS
Each flag has a time and a place but I find \f[I]+keep\f[R], and
\f[I]+write\f[R] to be the most useful out of the bunch.
.PP
The \f[I]+keep\f[R] flag can turn \f[I]wk\f[R] into a hydra of sorts.
I use this to control music playback on my system like this:
.IP
.EX
m \(dq+Music\(dq +keep
{
    c \(dqClear mpc\(dq %{{mpc clear}}
    d \(dqDisplay Song\(dq %{{songinfo}}
    h \(dqSeek \-5\(dq %{{mpc seek \(dq\-5\(dq}}
    l \(dqSeek +5\(dq %{{mpc seek \(dq+5\(dq}}
    n \(dqNext song\(dq %{{mpc next}}
    p \(dqPrev song\(dq %{{mpc prev}}
    o \(dqOpen mpc\(dq +close %{{st \-e ncmpcpp}}
    y \(dqPlaylist\(dq +close %{{st \-e ncmpcpp \-\-screen playlist}}
}
.EE
.PP
The \f[I]+write\f[R] flag is useful for scripting purposes.
In the same way that \f[B]dmenu\f[R]​(1) and co print selections to
stdout, this turns \f[B]wk\f[R]​(1) into a prompt for users to choose
from some list of options with less typing.
.SS WRAPPING COMMANDS
There are two classes of wrappers, globally through
\f[I]:wrap\-cmd\f[R], \f[I]\(enwrap\-cmd\f[R], and \f[I]wrapperCmd\f[R],
and locally through the \f[I]+wrap\f[R] flag.
All take a string argument, but the flag supports interpolation.
.PP
The global wrapper is most useful for someone using a uwsm managed
wayland environment.
Passing \f[I]\(enwrap\-cmd \(dquwsm\-app \(en\(dq\f[R] will ensure all
commands are prefixed with \f[I]uwsm\-app \(en\f[R] before they are run,
\f[B]or\f[R] written to stdout.
The following are equivilant examples:
.IP
.EX
# Wrapped
:wrap\-cmd \(dquwsm\-app \-\-\(dq
f \(dqFirefox\(dq %{{firefox}}

# Unwrapped
f \(dqFirefox\(dq %{{uwsm\-app \-\- firefox}}
.EE
.PP
Local wrappers may be useful with or without a global wrapper.
Here are some examples:
.IP
.EX
:wrap\-cmd \(dquwsm\-app \-\-\(dq
b \(dq+Browse\(dq +wrap \(dq%(wrap_cmd) firefox\(dq # include the global wrap_cmd
{
    g \(dqGNU\(dq %{{gnu.org}}
    [
        (y \(dqYouTube\(dq)
        (s \(dqSoundcloud\(dq)
    ] \(dqnull\(dq %{{%(desc,,).com}}
}
f \(dq+Foot\(dq +wrap \(dqfoot \-e\(dq # just wrap with \(dqfoot \-e\(dq
{
    n \(dqncmpcpp\(dq %{{ncmpcpp}}
}
.EE
.PP
\f[B]NOTE\f[R] on wrapper precedence: When multiple wrapper definitions
exist, the most specific takes precedence:
.IP "1." 3
Chord\-level +unwrap (no wrapper)
.IP "2." 3
Chord\-level +wrap \(dqcustom\(dq (use custom wrapper)
.IP "3." 3
Inherited +wrap from parent prefix
.IP "4." 3
Global :wrap\-cmd / \(enwrap\-cmd / wrapperCmd
.IP "5." 3
No wrapper set (no wrapping)
.SS THE INCLUDE MACRO
Here is an example of the \f[I]:include\f[R] macro:
.IP
.EX
# File main.wks
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
# Browser prefix
b \(dq+Browser\(dq { :include \(dqbrowser_key_chords.wks\(dq }
# Emacs prefix
e \(dq+Emacs\(dq \(habefore %{{xdotool set_desktop 1}} { :include \(dqemacs_key_chords.wks\(dq }
# Music prefix
m \(dq+Music\(dq +keep { :include \(dqmusic_key_chords.wks\(dq }

# File browser_key_chords.wks
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
[
    (b \(dqBrave\(dq)
    (c \(dqChrome\(dq)
    (f \(dqFirefox\(dq)
] \(dqnull\(dq %{{%(desc,,)}}

# Mullvad\-exclude prefix
m \(dq+Mullvad Exclude\(dq
{
    [
        (b \(dqBrave\(dq)
        (c \(dqChrome\(dq)
        (f \(dqFirefox\(dq)
    ] \(dqnull\(dq %{{mullvad\-exclude %(desc_)}}
}

# File emacs_key_chords.wks
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
b \(dqOpen blank\(dq %{{emacsclient \-c \-a \(dq\(dq}}
p \(dq+Projects\(dq
{
    w \(dqwk\(dq %{{emacs \(dq\(ti/Projects/wk\(dq}}
}

# File music_key_chords.wks
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
c \(dqClear mpc\(dq %{{mpc clear}}
d \(dqDisplay song\(dq %{{songinfo}}
h \(dqSeek \-5s\(dq %{{mpc seek \(dq\-5\(dq}}
l \(dqSeek +5s\(dq %{{mpc seek \(dq+5\(dq}}
n \(dqNext song\(dq %{{mpc next}}
p \(dqPrev song\(dq %{{mpc prev}}
o \(dqOpen mpc\(dq +close %{{st \-e ncmpcpp}}
.EE
.PP
This allows users to create key chords in a more modular manner.
This can be beneficial when you may want to reuse a \f[I]wks\f[R] file
in a different context than your main key chords.
.PP
You can even do silly things like this:
.IP
.EX
# File part_one.wks
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
A \(dqsilly :include \(dqpart_two.wks\(dq

# File part_two.wks
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
example\(dq %{{echo \(dqYou wouldn\(aqt do this right??\(dq}}

# Resulting wks file
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
A \(dqsilly example\(dq %{{echo \(dqYou wouldn\(aqt do this right??\(dq}}
.EE
.SS THE VAR MACRO
Here is an example of the \f[I]:var\f[R] macro:
.IP
.EX
# File main.wks
w \(dq+Workspace\(dq
{
    [asdfghjkl] \(dqWorkspace %(index+1)\(dq %{{%(WORKSPACE_CMD) %(index)}}
}

# File hyprland.wks
:var \(dqWORKSPACE_CMD\(dq \(dqhyprctl activateworkspace\(dq
:include \(dqmain.wks\(dq

# File dwm.wks
:var \(dqWORKSPACE_CMD\(dq \(dqxdotool set_desktop\(dq
:include \(dqmain.wks\(dq
.EE
.PP
With some clever orchestration you can use vars to construct a more
general \f[B]wk\f[R] menu, free from concern about your local
environment.
.SH NOTES
.SS INHERITANCE
Inheritance relates to hooks and flags given to prefixes.
The idea is fairly simple.
A hook or flag given to a prefix is inherited by any chord within the
prefix.
Nested prefixes do not inherit the hooks and flags given to their
parent.
.IP
.EX
a \(dq+Prefix\(dq +write
{
    w \(dqWrite it!\(dq %{{I get written!}}
    n \(dq+Nested Prefix\(dq
    {
        r \(dqRun it!\(dq %{{echo \(dqI get run!\(dq}}
    }
}
.EE
.PP
In the above example, the key chord \f[B]a w\f[R] causes \f[B]I get
written!\f[R] to be printed to stdout.
The key chord \f[B]a n r\f[R] runs the command \f[B]echo \(dqI get
run!\(dq\f[R].
.PP
To force a nested prefix to inherit from its parent the
\f[I]+inherit\f[R] flag must be given.
Additionally, if the prefix only wishes to inherit certain hooks or
flags additional flags may be given to ignore unwanted behavior.
.SS SORTING
Key chords will be sorted when processing a \f[I]wks\f[R] file if the
\f[B]\(ensort\f[R] flag is passed to \f[B]wk\f[R].
This has knock\-on effects with index interpolations (often for chord
arrays).
A \f[I]wks\f[R] file like this will produce different results sorted vs
unsorted (the default).
.IP
.EX
# Base file
[neio] \(dqSwitch %(index+1)\(dq %{{xdotool set_desktop %(index)}}
b \(dqSecond?\(dq +write %{{%(index)}}
a \(dqFirst?\(dq +write %{{%(index)}}

# Unsorted result
n \(dqSwitch 1\(dq %{{xdotool set_desktop 0}}
e \(dqSwitch 2\(dq %{{xdotool set_desktop 1}}
i \(dqSwitch 3\(dq %{{xdotool set_desktop 2}}
o \(dqSwitch 4\(dq %{{xdotool set_desktop 3}}
b \(dqSecond?\(dq +write %{{4}}
a \(dqFirst?\(dq +write %{{5}}

# Sorted result
a \(dqFirst?\(dq +write %{{0}}
b \(dqSecond?\(dq +write %{{1}}
e \(dqSwitch 3\(dq %{{xdotool set_desktop 2}}
i \(dqSwitch 4\(dq %{{xdotool set_desktop 3}}
n \(dqSwitch 5\(dq %{{xdotool set_desktop 4}}
o \(dqSwitch 6\(dq %{{xdotool set_desktop 5}}
.EE
.PP
To avoid this you can add the \f[I]+ignore\-sort\f[R] flag to any key
chord to ensure the value of the index interpolations.
.IP
.EX
# Base file
[neio] \(dqSwitch %(index+1)\(dq +ignore\-sort %{{xdotool set_desktop %(index)}}
b \(dqSecond?\(dq +write %{{%(index)}}
a \(dqFirst?\(dq +write %{{%(index)}}

# Sorted with \(ga+ignore\-sort\(ga result
e \(dqSwitch 1\(dq %{{xdotool set_desktop 0}}
i \(dqSwitch 2\(dq %{{xdotool set_desktop 1}}
n \(dqSwitch 3\(dq %{{xdotool set_desktop 2}}
o \(dqSwitch 4\(dq %{{xdotool set_desktop 3}}
a \(dqFirst?\(dq +write %{{4}}
b \(dqSecond?\(dq +write %{{5}}
.EE
.SS BUG REPORTS
Please see \f[B]wk\f[R]​(1) \f[B]BUG REPORTS\f[R] for info on reporting
bugs.
.SH AUTHORS
3L0C <dotbox at mailbox.org>.

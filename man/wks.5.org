#+title: WKS(5)
#+author: 3L0C

* NAME
wks - A which-key source file used by the *wk*​(1) program.

* DESCRIPTION
*wk* can generate /key chords/ using *wks* syntax instead of
relying on precompiled /key chords/.

* EXAMPLES
** BASIC WKS FILE
A basic *wks* file with some explanation regarding
*COMMENTS*, *CHORDS*, *PREFIXES*, *DESCRIPTIONS*, *KEYS*,
and *COMMANDS*:

#+begin_example
# This is a comment
    # This is also a comment

# This is a chord.
# The trigger key is 'a'.
# The description is "A chord".
# The command is 'echo "Hello, World"'.
a "A chord" %{{echo "Hello, world!"}}

# This is a prefix.
# The trigger key is 'Control + a'
C-a "A prefix"
{
    # This is a chord that can only be accessed after triggering the parent prefix.
    b "A chord" %{{echo "Hello from inside prefix 'C-a'"}}

    # Prefixes can nest additional prefixes arbitrarily deep
    c "Another prefix"
    {
        d "Done" %{{echo "You've reached the end!"}}
    }
}
#+end_example

** CHORD ARRAYS AND INTERPOLATION
The *CHORD ARRAY* and *INTERPOLATION* are more interesting
*wks* features:

#+begin_example
[abcdC-e] "Chord number: %(index+1)" %{{echo "Pressed key: '%(key)'"}}
#+end_example

The above is equivelent to the following:

#+begin_example
a   "Chord number: 1" %{{echo "Pressed key: 'a'"}}
b   "Chord number: 2" %{{echo "Pressed key: 'b'"}}
c   "Chord number: 3" %{{echo "Pressed key: 'c'"}}
d   "Chord number: 4" %{{echo "Pressed key: 'd'"}}
C-e "Chord number: 5" %{{echo "Pressed key: 'C-e'"}}
#+end_example

** CHORD ARRAYS AND CHORD EXPRESSIONS
The *CHORD ARRAY* also supports *CHORD EXPRESSIONS*:

#+begin_example
[
   abc
   (d "A different description" %{{echo "A different command"}})
   (C-e "An exciting description")
] "A default description" %{{echo "A default command"}}
#+end_example

The above is equivelent to the following:

#+begin_example
a   "A default description"   %{{echo "A default command"}}
b   "A default description"   %{{echo "A default command"}}
c   "A default description"   %{{echo "A default command"}}
d   "A different description" %{{echo "A different command"}}
C-e "An exciting description" %{{echo "A default command"}}
#+end_example

** HOOKS AND FLAGS IN CHORDS
*HOOKS* and *FLAGS* are very flexible:

#+begin_example
a "A hook"
  ^before %{{echo "I run first!"}}
  ^after %{{echo "I run last!"}}
    %{{echo "I run in the middle!"}}

b "A hook and flag"
  ^before %{{echo "I run first!"}}  +keep
    %{{echo "I stay open thanks to '+keep'"}}

c "I'm equivelent to 'b'"
  +keep ^before %{{echo "I run first!"}}
    %{{echo "I stay open thanks to '+keep'"}}
#+end_example

This should make two things clear:
- *1*. :: That /hooks/ and /flags/ are of equal precedence.
- *2*. :: That /hooks/ and /flags/ go inbetween the
  /description/ and the /command/.

** HOOKS AND FLAGS IN PREFIXES
A /hooks/ and /flags/ work differently when given to a
/prefix/ compared to a /chord/, /chord array/, or /chord
expression/:

#+begin_example
a "A prefix with a hook and flag" ^before %{{echo "I am /almost/ always run first!"}} +keep
{
    b "An obedient chord"
        %{{echo "I inherit /hooks/ and /flags/ from my parent prefix!"}}
    c "A selective chord" +no-before
        %{{echo "I ignore /before/ and /sync-before/ /hooks/!"}}
    d "A defiant chord" +ignore
        %{{echo "I ignore everything my parent prefix tries to force on me!!"}}
    e "A wanting child prefix" +inherit
    {
        f "Hooray!"
            %{{echo "My parent prefix is passing on my grandparent's /hooks/ and /flags/!"}}
    }
    g "An indifferent child prefix"
    {
        h "Hmm..."
           %{{echo "I don't seem to have inherited any /hooks/ or /flags/ from my grandparent."}}
    }
}
#+end_example

For a more formal understanding, see *INHERITANCE* below.

** THE INCLUDE PREPROCESSOR MACRO
Here is a simple example of the /:include/ *PREPROCESSOR
MACRO*:

#+begin_example
# File main.wks
---------------
:include "top_level_chords.wks"
:include "top_level_prefixes.wks"

# File top_level_chords.wks
---------------------------
a "A chord" %{{echo "Hello!"}}

# File top_level_prefixes.wks
-----------------------------
b "A prefix"
{
    c "A chord" %{{echo "Where am I??"}}
}
#+end_example

When processed, the /main.wks/ file will produce a *wks*
file equivelent to this:

#+begin_example
a "A chord" %{{echo "Hello!"}}
b "A prefix"
{
    c "A chord" %{{echo "Where am I??"}}
}
#+end_example

The /:include/ macro is more flexible than the *C*
equivelent though, allowing for silly things like this:

#+begin_example
# File first_half.wks
---------------------
a "The first half :include "second_half.wks"

# File second_half.wks
----------------------
and the second half" %{{echo "A match made in heaven."}}
#+end_example

Both /first_half.wks/ and /second_half.wks/ are invalid
*wks* files on their own. But, if /first_half.wks/ is passed
to *wk* it will produce a valid *wks* file equivelent to the
one below:

#+begin_example
a "The first half and the second half" %{{echo "A match made in heaven."}}
#+end_example

While the above example is a bit silly, this flexibility
allows *wks* to become extremely modular. Take this snippet
of my personal configuration for example:

#+begin_example
# File main.wks
---------------
# Browser prefix
b "+Browser" { :include "browser_key_chords.wks" }
# Emacs prefix
e "+Emacs" ^before %{{dwmc viewex 1}} { :include "emacs_key_chords.wks" }
# mpc prefix
m "+mpc" +keep { :include "mpc_key_chords.wks" }

# File browser_key_chords.wks
-----------------------------
[
    (b "Brave")
    (c "Chrome")
    (f "Firefox")
] "null" %{{%(desc,)}} # downcase the description and use as the command

# Mullvad-exclude prefix
m "+Mullvad Exclude"
{
    [
        (b "Brave")
        (c "Chrome")
        (f "Firefox")
    ] "null" %{{mullvad-exclude %(desc_)}}
}

# File emacs_key_chords.wks
---------------------------
b "Open blank" %{{emacsclient -c -a ""}}
p "+Projects"
{
    w "wk" %{{emacs "~/Projects/wk"}}
}

# File mpc_key_chords.wks
-------------------------
c "Clear mpc" %{{mpc clear}}
d "Display song" %{{songinfo}}
h "Seek -5s" %{{mpc seek "-5"}}
l "Seek +5s" %{{mpc seek "+5"}}
n "Next song" %{{mpc next}}
p "Prev song" %{{mpc prev}}
o "Open mpc" +ignore %{{term -e ncmpcpp}}
#+end_example

Each of the above files is perfectly valid on their own,
meaning they can exist in as part of /main.wks/, or I can
use only the relevant file when calling *wk* from a script.
Additionally, I can /:include/ files multiple times in cases
where I would be repeating myself.

* GRAMMAR RULES
The following are /ideally/ the formal grammar rules for
*wks*. I have tried to note where behavior differs from the
expectation. If anything is not behaving as you expect,
please see *CONTACT* below to reach out.

#+begin_example
key_chord          -> ( chord
                      | prefix
                      | chord_array ) ;

chord              -> key description keyword* command ;

prefix             -> key description keyword* '{' ( key_chord )+ '}' ;

chord_array        -> '[' ( key | chord_expression )+ ']' description keyword* command ;

chord_expression   -> '(' key description keyword* command? ')' ;

key                -> modifier* ( '\\'[\\\[\]{}#":^+()]
                                | [^\s\[\]{}#":^+()]
                                | special_key ) ;

special_key        -> ( 'Left' | 'Right' | 'Up'     | 'Down'
                      | 'TAB'  | 'SPC'   | 'RET'    | 'DEL'  | 'ESC'
                      | 'Home' | 'PgUp'  | 'PgDown' | 'End'  | 'Begin' ) ;

modifier           -> ( 'C' | 'H' | 'M' | 'S' ) '-' ;

description        -> '"' ( '\\"' | [^"] | interpolation )* '"' ;

command            -> '%{{' ( . | interpolation )* '}}' ;

interpolation      -> '%(' identifier ')' ;

identifier         -> ( 'key'
                      | 'index'
                      | 'index+1'
                      | 'desc'
                      | 'desc^'
                      | 'desc^^'
                      | 'desc,'
                      | 'desc,,' );

keyword            -> ( hook | flag ) ;

hook               -> '^' ( 'before'
                          | 'after'
                          | 'sync-before'
                          | 'sync-after' ) command ;

flag               -> '+' ( 'keep'
                          | 'close'
                          | 'inherit'
                          | 'ignore'
                          | 'unhook'
                          | 'deflag'
                          | 'no-before'
                          | 'no-after'
                          | 'write'
                          | 'execute'
                          | 'sync-command' ) ;

preprocessor_macro -> ':' ( string_macro
                          | switch_macro
                          | integer_macro
                          | unsigned_macro
                          | number_macro ) ;

string_macro       -> ( 'include'
                      | 'fg-color'
                      | 'bg-color'
                      | 'bd-color'
                      | 'shell'
                      | 'font' ) '"' ( '\\"' | [^"] )* '"' ) ;

switch_macro       -> ( 'debug'
                      | 'sort'
                      | 'top'
                      | 'bottom' );

integer_macro      -> ( 'window-width'
                      | 'window-gap' ) '-'? [0-9]+ ;

unsigned_macro     -> ( 'max-columns'
                      | 'border-width'
                      | 'width-padding'
                      | 'height-padding' ) [0-9]+ ;

number_macro       -> ( 'border-radius' ) [0-9]+ ( '.' [0-9]* )? ;
#+end_example

** KEY CHORD
A /key chord/ is the top-level construct in the grammar
and represents a complete key chord definition. It can be
either a /prefix/, a /chord/, or a /chord array/.

** PREFIX
A /prefix/ is a type of /key chord/ that acts as a container
for other key chords. It consists of a /key/, a
/description/, zero or more /keywords/, and a block of /key
chords/ enclosed in curly braces *{}*. The /key/ triggers
the /prefix/, and the inner /key chords/ become accessible
once the /prefix/ is activated.

** CHORD
A /chord/ is a basic /key chord/ that represents a single
action or /command/. It consists of a /key/, a
/description/, zero or more /keywords/, and a /command/.
When the specified /key/ is triggered, the associated
/command/ is executed.

** CHORD ARRAY
A /chord array/ is a compact way to define multiple key
chords with similar properties. It starts with an opening
square bracket *[*, followed by one or more /keys/ or
/chord expressions/, and ends with a closing square bracket *]*.
After the closing bracket, it includes a /description/,
zero or more /keywords/, and a /command/. Each /key/
within the /chord array/ represents a separate /chord/
that shares the same /description/, /keywords/, and
/command/. A /chord array/ will not produce a /prefix/
array. During parsing, an error will be thrown if no command
is supplied, just the same as a /chord/.

See *CHORD EXPRESSION* below for a description of the behavior of
/chord expressions/ within a /chord array/.

** CHORD EXPRESSION
A /chord expression/ is a construct that is only valid
within a /chord array/. A /chord expression/ begins with an
opening parentheses *(*, followed by a /key/ and
/description/. After the /description/, zero or more
/keywords/ and a /command/ may be given, just as one would
expect in a standard /chord/. However, a /chord
expression/ does not require anything more than the /key/
and /description/. This means it is possible to give a
/key/, /description/, and a /flag/ but no /hooks/ or
/command/ and vice versa. That is because anything missing
from the /chord expression/ will be filled in by the
surrounding /chord array/. In any case, the /chord
expression/ must be terminated by a closing parentheses *)*,
to be valid.

** KEY
A /key/ represents the trigger or activator for a /key
chord/. It consists of zero or more /modifiers/ followed
by either a single printable /UTF-8/ character, or a
/special key/. Certain characters have special meaning and
they cannot be used unless escaped.

All of the following characters must be preceded by a
backslash *\*, to be interpreted as a /key/:

#+begin_quote
- *[* :: Begins a /chord array/.
- *]* :: Ends a /chord array/.
- *{* :: Begins a /prefix/ block.
- *}* :: Ends a /prefix/ block.
- *#* :: Begins a comment.
- *"* :: Begins and ends a /description/.
- *:* :: Begins a /preprocessor macro/.
- *^* :: Begins a /hook/.
- *+* :: Begins a /flag/.
- *(* :: Begins a /chord expression/.
- *)* :: Ends a /chord expression/.
#+end_quote

While the above are required to be escaped to be interpreted
as a /key/, it is not an error to escape any /UTF-8/
character meant to be a /key/. The caveat is that the
character meant to be a /key/ needs to be printable and not
a predefined /special key/ as defined below.

** SPECIAL KEY
The /special keys/ cover (mostly) non-printable keys that can be used as a /key/.

The following are recognized /special key​/ forms:

#+begin_quote
/Left/,  /Right/,  /Up/,      /Down/,
/TAB/,   /SPC/,    /RET/,     /DEL/,       /ESC/,
/Home/,  /PgUp/,   /PgDown/,  /End/, and   /Begin/
#+end_quote

*NOTE* that several of the /special keys/ are technically
printable, and will be recognized as a regular /key/ if
escaped with a backslash *\*. You may escape a normal
*space* for use in your /key chords/, but when you hit
*space* it will be recognized as a /special key/ and will
fail to match the *space* /key/ in your /key chords/.

In short, please use the special forms listed above to
ensure the corresponding keypress events trigger the desired
/key chord/.

** MODIFIER
A /modifier/ is a prefix that can be added before any other
/modifier/, /key/, or /special key/ to specify the matching
keypress.  It consists of a single letter (*C*, *H*, *M*, or
*S*) followed by a hyphen *-*.  The modifiers represent the
following:

#+begin_quote
- *C-* :: /Control/ key
- *H-* :: /Hyper/ key
- *M-* :: /Meta/ key
- *S-* :: /Shift/ key
#+end_quote

*NOTE* that a /modifier/ can be given more than once
according to the grammar, but there is no practical benefit
to this. Additionally, the *S-* (/Shift/) /modifier/ will be
ignored for all non /special keys/. You can define a /key/
like *S-x*, but when you press *Shift+x*, *wk* will only
match the /key/ defined as *X*.

** DESCRIPTION
A /description/ provides a human-readable explanation or
label for a /key chord/. It is enclosed in double quotes
*"*. If a double quote needs to be included within the
/description/, it must be escaped with a backslash.

An /interpolation/ may be used with a /description/ as well.
See *INTERPOLATION* below for a full explanation.

** COMMAND
A /command/ represents the action or functionality triggered
by a /chord/. It is enclosed in *%{{* and *}}* delimiters.
The content within the delimiters can be any valid shell
/command/ just as you would supply it at the command-line.

An /interpolation/ may be used with a /command/. See
*INTERPOLATION* below for a full explanation.

*NOTE* any /command/ given to the /sync-before/, or
/sync-after/ /hooks/ will be run in a blocking manner.
Additionally, if the /sync-command/ /flag/ is given, the the
current /chord/'s /command/ becomes blocking. Depending on
the /command/ *wk* may never regain control. This is a
serious concern as *wk* only releases the keyboard after it
has completed or encountered an  error.  This could leave
the user with an unresponsive keyboard until they restart
their system. Think carefully before using a /command/ in a
blocking fashion.

** INTERPOLATION
An /interpolation/ works the same way in *wks* as it does in
many programming languages. An /interpolation/ may be given
within a /description/ or a /command/, except where
otherwise noted. An /interpolation/ begins with the *%(*
delimiter and ends with a closing parentheses *)*. Within
these delimiters, a single identifier must be given.

** IDENTIFIER
The following identifiers are valid within an /interpolation/:

#+begin_quote
- *key* ::
  The /key/ /identifier/ corresponds to the /key/ of the
  current /chord/. This makes the most sense to use within a
  /chord array/ or for a /chord/ that may change frequently
  or is not know ahead of time.

- *index* ::
  The /index/ /identifier/ corresponds to the 0 base index of
  the current /chord/ or /prefix/ within the current scope.
  *NOTE* a /prefix/ starts a new scope.

- *index+1* ::
  The /index+1/ /identifier/ corresponds to the 1 base index
  of the current /chord/ or /prefix/ within the current
  scope. *NOTE* a /prefix/ starts a new scope.

- *desc* and *description* ::
  The /desc/ and /description/ /identifiers/ correspond to the
  /description/ of the current /chord/ or /prefix/. Neither
  /identifier/ may not be given within a /description/. An
  error will be thrown in the case where this is attempted.
#+end_quote

** KEYWORD
A /keyword/ is an optional instruction to modify the
behavior of a /chord/ or /prefix/. The /keywords/ include
*HOOKS*, *FLAGS*, and *PREPROCESSOR COMMANDS*. See below for
details.

** HOOK
A /hook/ is a convenient way to add a /command/ to a
/chord/. A /hook/ may be given after a /description/
starting with a caret *^*, followed by a /hook/ and a
/command/. If multiple of the same /hooks/ are given to a
/key chord/ the final instance will overshadow the others.
The /hook/ /command/ is executed in accordance with the
specification for the type of /hook/.

The following are valid /hooks/:

#+begin_quote
- *before* /command/ ::
  The /command/ given to the /before/ /hook/ is executed
  before the current /chord/'s /command/, as the name
  implies. The /before/ /command/ is run asynchronously,
  meaning the /chord/'s /command/ may complete before the
  /before/ /command/ has completed execution. If you need
  the /chord/'s /command/ to be run in sync with the
  /before/ /command/, consider if there is some other way to
  achieve this before using the /sync-before/ /hook/.

- *after* /command/ ::
  The /command/ given to the /after/ /hook/ is executed
  after the current /chord/'s /command/, as the name
  implies. The /after/ /command/ is run asynchronously,
  meaning *wk* will not wait for the command to complete
  before resuming execution. I *wk* should wait until the
  /after/ /command/ completes you can use the /sync-after/
  /hook/. Just be certain you understand the pitfalls this
  introduces before you use that /hook/.

- *sync-before* /command/ ::
  The /command/ given to the /sync-before/ /hook/ is
  executed before the current /chord/'s /command/, as the
  name implies. Additionally, it is run in a blocking
  fashion, meaning *wk* will not resume control until after
  the command completes or is terminated. See the *COMMAND*
  section for best practices regarding blocking /commands/.

- *sync-after* /command/ ::
  The /command/ given to the /sync-after/ /hook/ is
  executed after the current /chord/'s /command/, as the
  name implies. Additionally, it is run in a blocking
  fashion, meaning *wk* will not resume control until after
  the command completes or is terminated. See the *COMMAND*
  section for best practices regarding blocking /commands/.
#+end_quote

See *INHERITANCE* for an explanation of how /hooks/ work
when given to a /prefix/.

See *EXAMPLES* for a demonstration on /hooks/.

** FLAG
A /flag/ is a convenient way to modify the behavior of a
/key chord/. A /flag/ may be passed after a /description/
begining with the plus character *+*. After the *+*, a
/flag/ name is specified.

The following are /flag/ names and how they affect the
behavior of *wk*:

#+begin_quote
- *keep* ::
  Normally, after executing a /chord/, *wk* will close. By
  supplying the /keep/ flag, *wk* will persist after the the
  /key chord/ is trigger. This enables you to trigger
  additional /key chords/ until a triggered /key chord/ does
  not supply the /keep/ /flag/ or no /key chords/ match the
  keypress event.

- *close* ::
  The /close/ /flag/ is the default behavior for any
  /chord/. However, a /chord/ may inherit the /keep/ /flag/
  from a surrounding /prefix/. When this new behavior is
  undesired specifying the /close/ /flag/ will restore the
  default behavior and end the *wk* program after the
  /chord/ is triggerd.

- *inherit* ::
  The /inherit/ /flag/ is only relevant to a child /prefix/
  that wants to /inherit/ /flags/ and /hooks/ from its
  parent /prefix/. Inheritance is not the norm, hence this
  /flag/ must be given explicitly.

- *unhook* ::
  The /unhook/ /flag/ causes a child /key chord/ to ignore
  all /flags/ and /hooks/ present in the parent /prefix/.
  Additional /hooks/ and /flags/ may be given to the child
  /key chord/ will work as expected.

- *no-before* ::
  The /no-before/ /flag/ prevents a child /key chord/ from
  inheriting a /before/ or /sync-before/ /hook/ present in
  the parent /prefix/. Any /before/ or /sync-before/ /hooks/
  given to the child /key chord/ will take precedence over
  those that may be inherited from a parent /prefix/. In
  this case, the /no-before/ /flag/ is redundant as the
  parent /hooks/ are overshadowed.

- *no-after* ::
  The /no-after/ /flag/ prevents a child /key chord/ from
  inheriting an /after/ or /sync-after/ /hook/ present in
  the parent /prefix/. Any /after/ or /sync-after/ /hooks/
  given to the child /key chord/ will take precedence over
  those that may be inherited from a parent /prefix/. In
  this case, the /no-after/ /flag/ is redundant as the
  parent /hooks/ are overshadowed.

- *write* ::
  By default, *wk* will execute a /chord/'s /command/ as
  though it were a shell command. When the /write/ /flag/ is
  passed, the /command/ of the affected /chord/ is simply
  written to the standard output. See *EXAMPLES* bleow if
  the effect is unclear.

- *sync-command* ::
  By default, *wk* will execute a /chord/'s /command/
  asynchronously. This means *wk* will continue execution
  despite the state of the /command/. If, for some reason, a
  /chord/'s /command/ should block *wk* from continuing
  until the /command/ ends, then you can supply the
  /sync-command/ /flag/. See *COMMAND* above to understand
  the pitfalls of blocking /commands/ in *wk*.
#+end_quote

See *INHERITANCE* for an explanation of how /flags/ work
when given to a /prefix/.

See *EXAMPLES* for a demonstration on /hooks/.

** PREPROCESSOR MACROS
A /preprocessor macro/ begins with a colon *:*, followed by
a supported macro.

The following are the supported /preprocessor macros/ and
their affects on *wks* files.

#+begin_quote
- *include* "/FILEPATH/" ::
  The /include/ /preprocessor macro/ acts in much the same
  way as the *C* macro by the same name. When the
  preprocessor spots an /include/ macro it will replace it
  with the contents of the given /file/. The /filepath/ may
  be a relative or absolute /path/ to some *wks* /file/. If
  the /filepath/ is relative it is assumed to be relative to
  the /filepath/ of the current *wks* /file/ being
  processed.  Absolute /filepaths/ are just that and not
  very interesting. One thing to note is that the /included/
  /file/ will be immediately loaded and then scanned by the
  preprocessor before the rest of the original file is
  scanned. This macro enables *wks* files to be quite
  modular as it can be given *anywhere* inside a *wks* file.
  This enables users to /include/ a *wks* file that is not
  valid when parsed on its own, but in the context of the
  /including/ *wks* file, it becomes valid. The opposite is
  also true. A perfectly valid *wks* file that /includes/ an
  invalid *wks* file in such a way that it does not become
  valid, will then itself become invalid. One bad apple and
  all that. See *EXAMPLES* for a demonstration.
#+end_quote


* NOTES
** INHERITANCE

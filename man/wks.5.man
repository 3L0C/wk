.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "WKS" "5" "April 3, 2024" "WKS Configuration Manual" ""
.SH NAME
wks - source file for \f[B]wk\f[R]​(1)
.SH DESCRIPTION
\f[B]wk\f[R] can generate key-chords using \f[B]wks\f[R] syntax.
.SH GRAMMAR RULES
The following are \f[I]ideally\f[R] the formal grammar rules for
\f[B]wks\f[R].
I have tried to note where behavior differs from the expectation.
If anything is not behaving as you expect, please see \f[B]CONTACT\f[R]
below to reach out.
.IP
.EX
key_chord     -> prefix
               | chord
               | chord_array ;

prefix        -> key description keyword* \[aq]{\[aq] ( key_chord )* \[aq]}\[aq] ;

chord         -> key description keyword* command ;

chord_array   -> \[aq][\[aq] ( key | key_pair )+ \[aq]]\[aq] description keyword* command ;

key_pair      -> \[aq](\[aq] key description \[aq])\[aq] ;

key           -> modifier* ( \[aq]\[rs]\[rs]\[aq][\[rs]\[rs]\[rs][\[rs]]{}#\[dq]:]
                           | [\[ha]\[rs]s\[rs][\[rs]]{}#\[dq]:]
                           | special_key ) ;

special_key   -> ( \[aq]Left\[aq] |  \[aq]Right\[aq]   |  \[aq]Up\[aq]        |  \[aq]Down\[aq]
                 | \[aq]TAB\[aq]  |  \[aq]SPC\[aq]     |  \[aq]RET\[aq]       |  \[aq]DEL\[aq] |  \[aq]ESC\[aq]
                 | \[aq]Home\[aq] |  \[aq]PgUp\[aq]    |  \[aq]PgDown\[aq]    |  \[aq]End\[aq] |  \[aq]Begin\[aq] ) ;

modifier      -> ( \[aq]C\[aq] | \[aq]H\[aq] | \[aq]M\[aq] | \[aq]S\[aq] ) \[aq]-\[aq] ;

description   -> \[aq]\[dq]\[aq] ( \[aq]\[rs]\[rs]\[dq]\[aq] | [\[ha]\[dq]] | interpolation )* \[aq]\[dq]\[aq] ;

command       -> \[aq]%{{\[aq] ( . | interpolation )* \[aq]}}\[aq] ;

interpolation -> \[aq]%(\[aq] identifier \[aq])\[aq] ;

identifier    -> ( \[aq]key\[aq]
                 | \[aq]index\[aq]
                 | \[aq]index+1\[aq]
                 | \[aq]desc\[aq]
                 | \[aq]description\[aq] ) ;

keyword       -> \[aq]:\[aq] ( hook | flag ) ;

hook          -> ( \[aq]before\[aq]
                 | \[aq]after\[aq]
                 | \[aq]async-before\[aq]
                 | \[aq]sync-after\[aq] ) command ;

flag          -> ( \[aq]keep\[aq]
                 | \[aq]close\[aq]
                 | \[aq]inherit\[aq]
                 | \[aq]unhook\[aq]
                 | \[aq]no-before\[aq]
                 | \[aq]no-after\[aq]
                 | \[aq]write\[aq]
                 | \[aq]sync-command\[aq] ) ;
.EE
.SS KEY CHORD
A \f[B]key chord\f[R] is the top-level construct in the grammar and
represents a complete key chord definition.
It can be either a \f[B]prefix\f[R], a \f[B]chord\f[R], or a \f[B]chord
array\f[R].
.SS PREFIX
A \f[B]prefix\f[R] is a type of \f[B]key chord\f[R] that acts as a
container for other key chords.
It consists of a \f[B]key\f[R], a \f[B]description\f[R], zero or more
\f[B]keyword\f[R]​s, and a block of \f[B]key chord\f[R]​s enclosed in
curly braces \f[B]{}\f[R].
The \f[B]key\f[R] triggers the \f[B]prefix\f[R], and the inner \f[B]key
chords\f[R] become accessible once the \f[B]prefix\f[R] is activated.
.SS CHORD
A \f[B]chord\f[R] is a basic \f[B]key chord\f[R] that represents a
single action or \f[B]command\f[R].
It consists of a \f[B]key\f[R], a \f[B]description\f[R], zero or more
\f[B]keyword\f[R]​s, and a \f[B]command\f[R].
When the specified \f[B]key\f[R] is triggered, the associated
\f[B]command\f[R] is executed.
.SS CHORD ARRAY
A \f[B]chord array\f[R] is a compact way to define multiple key chords
with similar properties.
It starts with an opening square bracket \f[B][\f[R], followed by one or
more \f[B]key\f[R]​s or \f[B]key pair\f[R]​s, and ends with a closing
square bracket \f[B]]\f[R].
After the closing bracket, it includes a \f[B]description\f[R], zero or
more \f[B]keyword\f[R]​s, and a \f[B]command\f[R].
Each \f[B]key\f[R] within the \f[B]chord array\f[R] represents a
separate \f[B]chord\f[R] that shares the same \f[B]description\f[R],
\f[B]keyword\f[R]​s, and \f[B]command\f[R].
A \f[B]chord array\f[R] will not produce a \f[B]prefix\f[R] array.
During parsing, an error will be thrown if no command is supplied, just
the same as a \f[B]chord\f[R].
.PP
See \f[B]KEY PAIR\f[R] below for a description of the behavior of
\f[B]key pair\f[R]​s within a \f[B]chord array\f[R].
.SS KEY PAIR
A \f[B]key pair\f[R] is a construct that is only valid within a
\f[B]chord array\f[R].
It is used to associate a \f[B]key\f[R] with a specific
\f[B]description\f[R].
It consists of a \f[B]key\f[R] and a \f[B]description\f[R] enclosed in
parentheses \f[B]()\f[R].
The \f[B]key pair\f[R] allows for individual key chords within a
\f[B]chord array\f[R] to have a different \f[B]description\f[R] while
sharing the same \f[B]keyword\f[R]​s and \f[B]command\f[R].
.SS KEY
A \f[B]key\f[R] represents the trigger or activator for a \f[B]key
chord\f[R].
It consists of zero or more \f[B]modifier\f[R]​s followed by either a
single printable \f[B]UTF-8\f[R] character, or a \f[B]special key\f[R].
Certain characters have special meaning and they cannot be used unless
escaped.
.PP
All of the following characters must be preceded by a backslash
\f[B]\[rs]\f[R] to be interpreted as a \f[B]key\f[R]:
.RS
.TP
\f[B][\f[R]
Begins a \f[B]chord array\f[R].
.TP
\f[B]]\f[R]
Ends a \f[B]chord array\f[R].
.TP
\f[B]{\f[R]
Begins a \f[B]prefix\f[R] block.
.TP
\f[B]}\f[R]
Ends a \f[B]prefix\f[R] block.
.TP
\f[B]#\f[R]
Begins a comment.
.TP
\f[B]\[dq]\f[R]
Begins and ends a \f[B]description\f[R].
.TP
\f[B]:\f[R]
Begins a \f[B]keyword\f[R].
.RE
.SS SPECIAL KEY
A \f[B]special key\f[R] represents a non-printable key that can be used
as a \f[B]key\f[R].
.PP
The following are valid \f[B]special key\f[R]​s:
.RS
.PP
\f[I]Left\f[R], \f[I]Right\f[R], \f[I]Up\f[R], \f[I]Down\f[R],
\f[I]TAB\f[R], \f[I]SPC\f[R], \f[I]RET\f[R], \f[I]DEL\f[R],
\f[I]ESC\f[R], \f[I]Home\f[R], \f[I]PgUp\f[R], \f[I]PgDown\f[R],
\f[I]End\f[R], and \f[I]Begin\f[R]
.RE
.SS MODIFIER
A \f[B]modifier\f[R] is a prefix that can be added before a
\f[B]key\f[R] to modify its behavior.
It consists of a single letter (\f[B]C\f[R], \f[B]H\f[R], \f[B]M\f[R],
or \f[B]S\f[R]) followed by a hyphen \f[B]-\f[R].
The modifiers represent the following:
.RS
.TP
\f[B]C-\f[R]
\f[I]Control\f[R] key
.TP
\f[B]H-\f[R]
\f[I]Hyper\f[R] key
.TP
\f[B]M-\f[R]
\f[I]Meta\f[R] key
.TP
\f[B]S-\f[R]
\f[I]Shift\f[R] key
.RE
.PP
A \f[B]modifier\f[R] can precede another \f[B]modifier\f[R] before a
\f[B]key\f[R].
\f[I]NOTE\f[R] that a \f[B]modifier\f[R] can be given more than once
according to the grammar, but there is no practical benefit to this.
Additionally, the \f[B]S-\f[R] (\f[I]Shift\f[R]) \f[B]modifier\f[R] can
be given before a printable character, but it will be ignored.
It is only considered when it precedes a \f[B]special key\f[R].
.SS DESCRIPTION
A \f[B]description\f[R] provides a human-readable explanation or label
for a key chord.
It is enclosed in double quotes \f[B]\[dq]\f[R].
If a double quote needs to be included within the \f[B]description\f[R],
it must be escaped with a backslash.
An \f[B]interpolation\f[R] may be used with a \f[B]description\f[R] as
well.
See \f[B]INTERPOLATION\f[R] below for a full explanation.
.SS COMMAND
A \f[B]command\f[R] represents the action or functionality triggered by
a \f[B]key chord\f[R].
It is enclosed in \f[B]%{{\f[R] and \f[B]}}\f[R] delimiters.
The content within the delimiters can be any valid \f[B]command\f[R]
just as you would supply it at the command-line.
An \f[B]interpolation\f[R] may be used with a \f[B]command\f[R].
See \f[B]INTERPOLATION\f[R] below for a full explanation.
.PP
\f[B]NOTE\f[R] any \f[B]command\f[R] given to the \f[I]before\f[R], or
\f[I]sync-after\f[R] \f[B]hook\f[R]​s is blocking.
Additionally, if the \f[I]sync-command\f[R] \f[B]flag\f[R] is given, the
the current \f[B]chord\f[R]\[aq]s \f[B]command\f[R] becomes blocking.
Depending on the \f[B]command\f[R], \f[B]wk\f[R] may never regain
control.
This is a serious concern as \f[B]wk\f[R] only releases the keyboard
after it has completed or encountered an error.
This could leave the user with an unresponsive keyboard until they
restart their system.
Think carefully before using a \f[B]command\f[R] in a blocking fashion,
and if possible, use the non-blocking alternatives.
.SS INTERPOLATION
An \f[B]interpolation\f[R] works the same way in \f[B]wks\f[R] as it
does in many programming languages.
An \f[B]interpolation\f[R] may be given within a \f[B]description\f[R]
or a \f[B]command\f[R], except where otherwise noted.
An \f[B]interpolation\f[R] begins with the \f[B]%(\f[R] delimiter and
ends with a closing parentheses \f[B])\f[R].
Within these delimiters, a single identifier must be given.
.SS IDENTIFIER
The following identifiers are valid within an \f[B]interpolation\f[R]:
.RS
.TP
\f[I]key\f[R]
The \f[I]key\f[R] \f[B]identifier\f[R] corresponds to the \f[B]key\f[R]
of the current \f[B]chord\f[R].
This makes the most sense to use within a \f[B]chord array\f[R] or for a
\f[B]chord\f[R] that may change frequently or is not know ahead of time.
.TP
\f[I]index\f[R]
The \f[I]index\f[R] \f[B]identifier\f[R] corresponds to the 0 base index
of the current \f[B]chord\f[R] or \f[B]prefix\f[R] within the current
scope.
\f[B]NOTE\f[R] a \f[B]prefix\f[R] starts a new scope.
.TP
\f[I]index+1\f[R]
The \f[I]index+1\f[R] \f[B]identifier\f[R] corresponds to the 1 base
index of the current \f[B]chord\f[R] or \f[B]prefix\f[R] within the
current scope.
\f[B]NOTE\f[R] a \f[B]prefix\f[R] starts a new scope.
.TP
\f[I]desc\f[R] and \f[I]description\f[R]
The \f[I]desc\f[R] and \f[I]description\f[R] \f[B]identifier\f[R]​s
correspond to the \f[B]description\f[R] of the current \f[B]chord\f[R]
or \f[B]prefix\f[R].
Neither \f[B]identifier\f[R] may not be given within a
\f[B]description\f[R].
An error will be thrown in the case where this is attempted.
.RE
.SS KEYWORD
A \f[B]keyword\f[R] is an optional instruction to modify the behavior of
a \f[B]chord\f[R] or \f[B]prefix\f[R].
Is starts with a colon \f[B]:\f[R] followed by a \f[B]hook\f[R] or a
\f[B]flag\f[R].
.SS HOOK
A \f[B]hook\f[R] is a convenient way to add a \f[B]command\f[R] to a
\f[B]chord\f[R].
The \f[B]hook\f[R] \f[B]command\f[R] is executed in accordance with the
specification for the type of \f[B]hook\f[R].
.PP
The following are valid \f[B]hook\f[R]​s:
.RS
.TP
\f[I]before\f[R] \f[B]command\f[R]
The \f[B]command\f[R] given to the \f[I]before\f[R] \f[B]hook\f[R] is
executed before the current \f[B]chord\f[R]\[aq]s \f[B]command\f[R], as
the name implies.
The \f[B]chord\f[R]\[aq]s \f[B]command\f[R] will not run until the
\f[I]before\f[R] \f[B]command\f[R] completes execution.
See the \f[B]COMMAND\f[R] section for best practices regarding blocking
\f[B]command\f[R]​s.
.TP
\f[I]after\f[R] \f[B]command\f[R]
The \f[B]command\f[R] given to the \f[I]after\f[R] \f[B]hook\f[R] is
executed after the current \f[B]chord\f[R]\[aq]s \f[B]command\f[R], as
the name implies.
The \f[I]after\f[R] \f[B]command\f[R] is executed as a separate
non-blocking process like a \f[B]chord\f[R]\[aq]s command, meaning
\f[B]wk\f[R] will not wait for the \f[I]after\f[R] \f[B]command\f[R] to
complete before it continues its business.
.TP
\f[I]async-before\f[R] \f[B]command\f[R]
The \f[B]command\f[R] given to the \f[I]async-before\f[R] \f[B]hook\f[R]
is executed before the current \f[B]chord\f[R]\[aq]s \f[B]command\f[R],
as the name implies.
Additionally, it is executed as a separate non-blocking process.
The \f[B]chord\f[R]\[aq]s \f[B]command\f[R] will run right after the
\f[I]async-before\f[R] \f[B]command\f[R] is dispatched, regardless of if
or when the \f[I]async-before\f[R] \f[B]command\f[R] has completed.
.TP
\f[I]sync-after\f[R] \f[B]command\f[R]
The \f[B]command\f[R] given to the \f[I]sync-after\f[R] \f[B]hook\f[R]
is executed after the current \f[B]chord\f[R]\[aq]s \f[B]command\f[R],
as the name implies.
The \f[I]sync-after\f[R] \f[B]command\f[R] is executed as a blocking
process, meaning \f[B]wk\f[R] may never close if the \f[B]command\f[R]
does not complete execution.
See the \f[B]COMMAND\f[R] section for best practices regarding blocking
\f[B]command\f[R]​s.
.RE
.SS FLAG
A \f[B]flag\f[R] is a convenient way to modify the behavior of a
\f[B]chord\f[R] or \f[B]prefix\f[R].
When given to a \f[B]prefix\f[R] the \f[B]flag\f[R] is passed on to all
\f[B]chord\f[R]​s and \f[B]chord array\f[R]​s in the \f[B]prefix\f[R], but
not any children \f[B]prefix\f[R]​es.
.PP
The following are valid \f[B]flag\f[R]​s:
.RS
.TP
\f[I]keep\f[R]
Normally, after executing a \f[B]chord\f[R], \f[B]wk\f[R] will close.
By supplying the \f[I]keep\f[R] flag, the \f[B]wk\f[R] window will
persist for any \f[B]chord\f[R] that is given the \f[I]keep\f[R]
\f[B]flag\f[R].
This includes explicitly supplying the \f[B]flag\f[R] and when it is
inherited from a surrounding \f[B]prefix\f[R].
.TP
\f[I]close\f[R]
The \f[I]close\f[R] \f[B]flag\f[R] is the default behavior for any
\f[B]chord\f[R].
However, a \f[B]chord\f[R] may inherit the \f[I]keep\f[R] \f[B]flag\f[R]
from a surrounding \f[B]prefix\f[R].
When this new behavior is undesired specifying the \f[I]close\f[R] flag
will restore the default behavior and end the \f[B]wk\f[R] program after
the \f[B]chord\f[R] is completed.
.TP
\f[I]inherit\f[R]
The \f[I]inherit\f[R] \f[B]flag\f[R] is only relevant to a child
\f[B]prefix\f[R] that wants to \f[I]inherit\f[R] \f[B]flag\f[R]​s and
\f[B]hook\f[R]​s from the parent \f[B]prefix\f[R].
Inheritance is not the norm, hence this \f[B]flag\f[R] must be given
explicitly.
.TP
\f[I]unhook\f[R]
The \f[I]unhook\f[R] \f[B]flag\f[R] causes a child \f[B]chord\f[R] to
ignore all \f[B]flag\f[R]​s and \f[B]hook\f[R]​s present in the parent.
This does not effect those given to the \f[B]chord\f[R] explicitly.
.TP
\f[I]no-before\f[R]
The \f[I]no-before\f[R] \f[B]flag\f[R] prevents a child \f[B]chord\f[R]
from inheriting a \f[I]before\f[R] or \f[I]async-before\f[R]
\f[B]hook\f[R] present in the parent \f[B]prefix\f[R].
.TP
\f[I]no-after\f[R]
The \f[I]no-after\f[R] \f[B]flag\f[R] prevents a child \f[B]chord\f[R]
from inheriting an \f[I]after\f[R] or \f[I]sync-after\f[R]
\f[B]hook\f[R] present in the parent \f[B]prefix\f[R].
.TP
\f[I]write\f[R]
By default, \f[B]wk\f[R] will execute a \f[B]chord\f[R]
\f[B]command\f[R] as though it were a shell command.
When the \f[I]write\f[R] \f[B]flag\f[R] is present, the
\f[B]command\f[R] of the affected \f[B]chord\f[R] is simply written to
the standard output.
.TP
\f[I]sync-command\f[R]
By default, \f[B]wk\f[R] will execute a \f[B]chord\f[R]
\f[B]command\f[R] in a separate process to prevent any hangup for a
\f[B]command\f[R] that may never exit.
If it makes more sense for \f[B]wk\f[R] to wait for the command to
complete before it continues, then provide the \f[I]sync-command\f[R]
\f[B]flag\f[R].
\f[B]NOTE\f[R] that this could prevent \f[B]wk\f[R] from closing which
is concerning as it retains control of the user keyboard throughout
execution.
You may need to restart your system if used improperly.
.RE
.SH AUTHORS
3L0C.

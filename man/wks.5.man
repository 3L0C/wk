.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "WKS" "5" "" "" ""
.SH NAME
wks - A which-key source file used by the \f[B]wk\f[R]​(1) program.
.SH DESCRIPTION
\f[B]wk\f[R] can generate \f[I]key chords\f[R] using \f[B]wks\f[R]
syntax instead of relying on precompiled \f[I]key chords\f[R].
.SH EXAMPLES
.SS BASIC WKS FILE
A basic \f[B]wks\f[R] file with some explanation regarding
\f[B]COMMENTS\f[R], \f[B]CHORDS\f[R], \f[B]PREFIXES\f[R],
\f[B]DESCRIPTIONS\f[R], \f[B]KEYS\f[R], and \f[B]COMMANDS\f[R]:
.IP
.EX
# This is a comment
    # This is also a comment

# This is a chord.
# The trigger key is \[aq]a\[aq].
# The description is \[dq]A chord\[dq].
# The command is \[aq]echo \[dq]Hello, World\[dq]\[aq].
a \[dq]A chord\[dq] %{{echo \[dq]Hello, world!\[dq]}}

# This is a prefix.
# The trigger key is \[aq]Control + a\[aq]
C-a \[dq]A prefix\[dq]
{
    # This is a chord that can only be accessed after triggering the parent prefix.
    b \[dq]A chord\[dq] %{{echo \[dq]Hello from inside prefix \[aq]C-a\[aq]\[dq]}}

    # Prefixes can nest additional prefixes arbitrarily deep
    c \[dq]Another prefix\[dq]
    {
        d \[dq]Done\[dq] %{{echo \[dq]You\[aq]ve reached the end!\[dq]}}
    }
}
.EE
.SS CHORD ARRAYS AND INTERPOLATION
The \f[B]CHORD ARRAY\f[R] and \f[B]INTERPOLATION\f[R] are more
interesting \f[B]wks\f[R] features:
.IP
.EX
[abcdC-e] \[dq]Chord number: %(index+1)\[dq] %{{echo \[dq]Pressed key: \[aq]%(key)\[aq]\[dq]}}
.EE
.PP
The above is equivelent to the following:
.IP
.EX
a   \[dq]Chord number: 1\[dq] %{{echo \[dq]Pressed key: \[aq]a\[aq]\[dq]}}
b   \[dq]Chord number: 2\[dq] %{{echo \[dq]Pressed key: \[aq]b\[aq]\[dq]}}
c   \[dq]Chord number: 3\[dq] %{{echo \[dq]Pressed key: \[aq]c\[aq]\[dq]}}
d   \[dq]Chord number: 4\[dq] %{{echo \[dq]Pressed key: \[aq]d\[aq]\[dq]}}
C-e \[dq]Chord number: 5\[dq] %{{echo \[dq]Pressed key: \[aq]C-e\[aq]\[dq]}}
.EE
.SS CHORD ARRAYS AND CHORD EXPRESSIONS
The \f[B]CHORD ARRAY\f[R] also supports \f[B]CHORD EXPRESSIONS\f[R]:
.IP
.EX
[
   abc
   (d \[dq]A different description\[dq] %{{echo \[dq]A different command\[dq]}})
   (C-e \[dq]An exciting description\[dq])
] \[dq]A default description\[dq] %{{echo \[dq]A default command\[dq]}}
.EE
.PP
The above is equivelent to the following:
.IP
.EX
a   \[dq]A default description\[dq]   %{{echo \[dq]A default command\[dq]}}
b   \[dq]A default description\[dq]   %{{echo \[dq]A default command\[dq]}}
c   \[dq]A default description\[dq]   %{{echo \[dq]A default command\[dq]}}
d   \[dq]A different description\[dq] %{{echo \[dq]A different command\[dq]}}
C-e \[dq]An exciting description\[dq] %{{echo \[dq]A default command\[dq]}}
.EE
.SS HOOKS AND FLAGS IN CHORDS
\f[B]HOOKS\f[R] and \f[B]FLAGS\f[R] are very flexible:
.IP
.EX
a \[dq]A hook\[dq]
  \[ha]before %{{echo \[dq]I run first!\[dq]}}
  \[ha]after %{{echo \[dq]I run last!\[dq]}}
    %{{echo \[dq]I run in the middle!\[dq]}}

b \[dq]A hook and flag\[dq]
  \[ha]before %{{echo \[dq]I run first!\[dq]}}  +keep
    %{{echo \[dq]I stay open thanks to \[aq]+keep\[aq]\[dq]}}

c \[dq]I\[aq]m equivelent to \[aq]b\[aq]\[dq]
  +keep \[ha]before %{{echo \[dq]I run first!\[dq]}}
    %{{echo \[dq]I stay open thanks to \[aq]+keep\[aq]\[dq]}}
.EE
.PP
This should make two things clear:
.TP
\f[B]1\f[R].
That \f[I]hooks\f[R] and \f[I]flags\f[R] are of equal precedence.
.TP
\f[B]2\f[R].
That \f[I]hooks\f[R] and \f[I]flags\f[R] go inbetween the
\f[I]description\f[R] and the \f[I]command\f[R].
.SS HOOKS AND FLAGS IN PREFIXES
A \f[I]hooks\f[R] and \f[I]flags\f[R] work differently when given to a
\f[I]prefix\f[R] compared to a \f[I]chord\f[R], \f[I]chord array\f[R],
or \f[I]chord expression\f[R]:
.IP
.EX
a \[dq]A prefix with a hook and flag\[dq] \[ha]before %{{echo \[dq]I am /almost/ always run first!\[dq]}} +keep
{
    b \[dq]An obedient chord\[dq]
        %{{echo \[dq]I inherit /hooks/ and /flags/ from my parent prefix!\[dq]}}
    c \[dq]A selective chord\[dq] +no-before
        %{{echo \[dq]I ignore /before/ and /sync-before/ /hooks/!\[dq]}}
    d \[dq]A defiant chord\[dq] +ignore
        %{{echo \[dq]I ignore everything my parent prefix tries to force on me!!\[dq]}}
    e \[dq]A wanting child prefix\[dq] +inherit
    {
        f \[dq]Hooray!\[dq]
            %{{echo \[dq]My parent prefix is passing on my grandparent\[aq]s /hooks/ and /flags/!\[dq]}}
    }
    g \[dq]An indifferent child prefix\[dq]
    {
        h \[dq]Hmm...\[dq]
           %{{echo \[dq]I don\[aq]t seem to have inherited any /hooks/ or /flags/ from my grandparent.\[dq]}}
    }
}
.EE
.PP
For a more formal understanding, see \f[B]INHERITENCE\f[R] below.
.SS THE INCLUDE PREPROCESSOR MACRO
Here is a simple example of the \f[I]:include\f[R] \f[B]PREPROCESSOR
MACRO\f[R]:
.IP
.EX
# File main.wks
---------------
:include \[dq]top_level_chords.wks\[dq]
:include \[dq]top_level_prefixes.wks\[dq]

# File top_level_chords.wks
---------------------------
a \[dq]A chord\[dq] %{{echo \[dq]Hello!\[dq]}}

# File top_level_prefixes.wks
-----------------------------
b \[dq]A prefix\[dq]
{
    c \[dq]A chord\[dq] %{{echo \[dq]Where am I??\[dq]}}
}
.EE
.PP
When processed, the \f[I]main.wks\f[R] file will produce a \f[B]wks\f[R]
file equivelent to this:
.IP
.EX
a \[dq]A chord\[dq] %{{echo \[dq]Hello!\[dq]}}
b \[dq]A prefix\[dq]
{
    c \[dq]A chord\[dq] %{{echo \[dq]Where am I??\[dq]}}
}
.EE
.PP
The \f[I]:include\f[R] macro is more flexible than the \f[B]C\f[R]
equivelent though, allowing for silly things like this:
.IP
.EX
# File first_half.wks
---------------------
a \[dq]The first half :include \[dq]second_half.wks\[dq]

# File second_half.wks
----------------------
and the second half\[dq] %{{echo \[dq]A match made in heaven.\[dq]}}
.EE
.PP
Both \f[I]first~half~.wks\f[R] and \f[I]second~half~.wks\f[R] are
invalid \f[B]wks\f[R] files on their own.
But, if \f[I]first~half~.wks\f[R] is passed to \f[B]wk\f[R] it will
produce a valid \f[B]wks\f[R] file equivelent to the one below:
.IP
.EX
a \[dq]The first half and the second half\[dq] %{{echo \[dq]A match made in heaven.\[dq]}}
.EE
.PP
While the above example is a bit silly, this flexibility allows
\f[B]wks\f[R] to become extremely modular.
Take this snippet of my personal configuration for example:
.IP
.EX
# File main.wks
---------------
# Browser prefix
b \[dq]+Browser\[dq] { :include \[dq]browser_key_chords.wks\[dq] }
# Emacs prefix
e \[dq]+Emacs\[dq] \[ha]before %{{dwmc viewex 1}} { :include \[dq]emacs_key_chords.wks\[dq] }
# mpc prefix
m \[dq]+mpc\[dq] +keep { :include \[dq]mpc_key_chords.wks\[dq] }

# File browser_key_chords.wks
-----------------------------
[
    (b \[dq]Brave\[dq])
    (c \[dq]Chrome\[dq])
    (f \[dq]Firefox\[dq])
] \[dq]null\[dq] %{{%(desc,)}} # downcase the description and use as the command

# Mullvad-exclude prefix
m \[dq]+Mullvad Exclude\[dq]
{
    [
        (b \[dq]Brave\[dq])
        (c \[dq]Chrome\[dq])
        (f \[dq]Firefox\[dq])
    ] \[dq]null\[dq] %{{mullvad-exclude %(desc_)}}
}

# File emacs_key_chords.wks
---------------------------
b \[dq]Open blank\[dq] %{{emacsclient -c -a \[dq]\[dq]}}
p \[dq]+Projects\[dq]
{
    w \[dq]wk\[dq] %{{emacs \[dq]\[ti]/Projects/wk\[dq]}}
}

# File mpc_key_chords.wks
-------------------------
c \[dq]Clear mpc\[dq] %{{mpc clear}}
d \[dq]Display song\[dq] %{{songinfo}}
h \[dq]Seek -5s\[dq] %{{mpc seek \[dq]-5\[dq]}}
l \[dq]Seek +5s\[dq] %{{mpc seek \[dq]+5\[dq]}}
n \[dq]Next song\[dq] %{{mpc next}}
p \[dq]Prev song\[dq] %{{mpc prev}}
o \[dq]Open mpc\[dq] +ignore %{{term -e ncmpcpp}}
.EE
.PP
Each of the above files is perfectly valid on their own, meaning they
can exist in as part of \f[I]main.wks\f[R], or I can use only the
relevant file when calling \f[B]wk\f[R] from a script.
Additionally, I can \f[I]:include\f[R] files multiple times in cases
where I would be repeating myself.
.SH GRAMMAR RULES
The following are \f[I]ideally\f[R] the formal grammar rules for
\f[B]wks\f[R].
I have tried to note where behavior differs from the expectation.
If anything is not behaving as you expect, please see \f[B]CONTACT\f[R]
below to reach out.
.IP
.EX
key_chord          -> prefix
                    | chord
                    | chord_array ;

prefix             -> key description keyword* \[aq]{\[aq] ( key_chord )* \[aq]}\[aq] ;

chord              -> key description keyword* command ;

chord_array        -> \[aq][\[aq] ( key | chord_expression )+ \[aq]]\[aq] description keyword* command ;

chord_expression   -> \[aq](\[aq] chord \[aq])\[aq] ;

key                -> modifier* ( \[aq]\[rs]\[rs]\[aq][\[rs]\[rs]\[rs][\[rs]]{}#\[dq]:\[ha]+()]
                                | [\[ha]\[rs]s\[rs][\[rs]]{}#\[dq]:\[ha]+()]
                                | special_key ) ;

special_key        -> ( \[aq]Left\[aq] | \[aq]Right\[aq] | \[aq]Up\[aq]     | \[aq]Down\[aq]
                      | \[aq]TAB\[aq]  | \[aq]SPC\[aq]   | \[aq]RET\[aq]    | \[aq]DEL\[aq]  | \[aq]ESC\[aq]
                      | \[aq]Home\[aq] | \[aq]PgUp\[aq]  | \[aq]PgDown\[aq] | \[aq]End\[aq]  | \[aq]Begin\[aq] ) ;

modifier           -> ( \[aq]C\[aq] | \[aq]H\[aq] | \[aq]M\[aq] | \[aq]S\[aq] ) \[aq]-\[aq] ;

description        -> \[aq]\[dq]\[aq] ( \[aq]\[rs]\[rs]\[dq]\[aq] | [\[ha]\[dq]] | interpolation )* \[aq]\[dq]\[aq] ;

command            -> \[aq]%{{\[aq] ( . | interpolation )* \[aq]}}\[aq] ;

interpolation      -> \[aq]%(\[aq] identifier \[aq])\[aq] ;

identifier         -> ( \[aq]key\[aq]
                      | \[aq]index\[aq]
                      | \[aq]index+1\[aq]
                      | \[aq]desc\[aq]
                      | \[aq]desc\[ha]\[aq]
                      | \[aq]desc\[ha]\[ha]\[aq]
                      | \[aq]desc,\[aq]
                      | \[aq]desc,,\[aq] );

keyword            -> ( hook | flag ) ;

hook               -> \[aq]\[ha]\[aq] ( \[aq]before\[aq]
                          | \[aq]after\[aq]
                          | \[aq]sync-before\[aq]
                          | \[aq]sync-after\[aq] ) command ;

flag               -> \[aq]+\[aq] ( \[aq]keep\[aq]
                          | \[aq]close\[aq]
                          | \[aq]inherit\[aq]
                          | \[aq]ignore\[aq]
                          | \[aq]unhook\[aq]
                          | \[aq]deflag\[aq]
                          | \[aq]no-before\[aq]
                          | \[aq]no-after\[aq]
                          | \[aq]write\[aq]
                          | \[aq]sync-command\[aq] ) ;

preprocessor_macro -> \[aq]:\[aq] ( \[aq]include\[aq] \[aq]\[dq]\[aq] [\[ha]\[dq]]+ \[aq]\[dq]\[aq] ) ;
.EE
.SS KEY CHORD
A \f[I]key chord\f[R] is the top-level construct in the grammar and
represents a complete key chord definition.
It can be either a \f[I]prefix\f[R], a \f[I]chord\f[R], or a \f[I]chord
array\f[R].
.SS PREFIX
A \f[I]prefix\f[R] is a type of \f[I]key chord\f[R] that acts as a
container for other key chords.
It consists of a \f[I]key\f[R], a \f[I]description\f[R], zero or more
\f[I]keywords\f[R], and a block of \f[I]key chords\f[R] enclosed in
curly braces \f[B]{}\f[R].
The \f[I]key\f[R] triggers the \f[I]prefix\f[R], and the inner \f[I]key
chords\f[R] become accessible once the \f[I]prefix\f[R] is activated.
.SS CHORD
A \f[I]chord\f[R] is a basic \f[I]key chord\f[R] that represents a
single action or \f[I]command\f[R].
It consists of a \f[I]key\f[R], a \f[I]description\f[R], zero or more
\f[I]keywords\f[R], and a \f[I]command\f[R].
When the specified \f[I]key\f[R] is triggered, the associated
\f[I]command\f[R] is executed.
.SS CHORD ARRAY
A \f[I]chord array\f[R] is a compact way to define multiple key chords
with similar properties.
It starts with an opening square bracket \f[B][\f[R], followed by one or
more \f[I]keys\f[R] or \f[I]chord expressions\f[R], and ends with a
closing square bracket \f[B]]\f[R].
After the closing bracket, it includes a \f[I]description\f[R], zero or
more \f[I]keywords\f[R], and a \f[I]command\f[R].
Each \f[I]key\f[R] within the \f[I]chord array\f[R] represents a
separate \f[I]chord\f[R] that shares the same \f[I]description\f[R],
\f[I]keywords\f[R], and \f[I]command\f[R].
A \f[I]chord array\f[R] will not produce a \f[I]prefix\f[R] array.
During parsing, an error will be thrown if no command is supplied, just
the same as a \f[I]chord\f[R].
.PP
See \f[B]CHORD EXPRESSION\f[R] below for a description of the behavior
of \f[I]chord expressions\f[R] within a \f[I]chord array\f[R].
.SS CHORD EXPRESSION
A \f[I]chord expression\f[R] is a construct that is only valid within a
\f[I]chord array\f[R].
A \f[I]chord expression\f[R] begins with an opening parentheses
\f[B](\f[R], followed by a \f[I]key\f[R] and \f[I]description\f[R].
After the \f[I]description\f[R], zero or more \f[I]keywords\f[R] and a
\f[I]command\f[R] may be given, just as one would expect in a standard
\f[I]chord\f[R].
However, a \f[I]chord expression\f[R] does not require anything more
than the \f[I]key\f[R] and \f[I]description\f[R].
This means it is possible to give a \f[I]key\f[R],
\f[I]description\f[R], and a \f[I]flag\f[R] but no \f[I]hooks\f[R] or
\f[I]command\f[R] and vice versa.
That is because anything missing from the \f[I]chord expression\f[R]
will be filled in by the surrounding \f[I]chord array\f[R].
In any case, the \f[I]chord expression\f[R] must be terminated by a
closing parentheses \f[B])\f[R], to be valid.
.SS KEY
A \f[I]key\f[R] represents the trigger or activator for a \f[I]key
chord\f[R].
It consists of zero or more \f[I]modifiers\f[R] followed by either a
single printable \f[I]UTF-8\f[R] character, or a \f[I]special key\f[R].
Certain characters have special meaning and they cannot be used unless
escaped.
.PP
All of the following characters must be preceded by a backslash
\f[B]\[rs]\f[R], to be interpreted as a \f[I]key\f[R]:
.RS
.TP
\f[B][\f[R]
Begins a \f[I]chord array\f[R].
.TP
\f[B]]\f[R]
Ends a \f[I]chord array\f[R].
.TP
\f[B]{\f[R]
Begins a \f[I]prefix\f[R] block.
.TP
\f[B]}\f[R]
Ends a \f[I]prefix\f[R] block.
.TP
\f[B]#\f[R]
Begins a comment.
.TP
\f[B]\[dq]\f[R]
Begins and ends a \f[I]description\f[R].
.TP
\f[B]:\f[R]
Begins a \f[I]preprocessor macro\f[R].
.TP
*^*^
Begins a \f[I]hook\f[R].
.TP
\f[B]+\f[R]
Begins a \f[I]flag\f[R].
.TP
\f[B](\f[R]
Begins a \f[I]chord expression\f[R].
.TP
\f[B])\f[R]
Ends a \f[I]chord expression\f[R].
.RE
.PP
While the above are required to be escaped to be interpreted as a
\f[I]key\f[R], it is not an error to escape any \f[I]UTF-8\f[R]
character meant to be a \f[I]key\f[R].
The caveat is that the character meant to be a \f[I]key\f[R] needs to be
printable and not a predefined \f[I]special key\f[R] as defined below.
.SS SPECIAL KEY
The \f[I]special keys\f[R] cover (mostly) non-printable keys that can be
used as a \f[I]key\f[R].
.PP
The following are recognized /special key​/ forms:
.RS
.PP
\f[I]Left\f[R], \f[I]Right\f[R], \f[I]Up\f[R], \f[I]Down\f[R],
\f[I]TAB\f[R], \f[I]SPC\f[R], \f[I]RET\f[R], \f[I]DEL\f[R],
\f[I]ESC\f[R], \f[I]Home\f[R], \f[I]PgUp\f[R], \f[I]PgDown\f[R],
\f[I]End\f[R], and \f[I]Begin\f[R]
.RE
.PP
\f[B]NOTE\f[R] that several of the \f[I]special keys\f[R] are
technically printable, and will be recognized as a regular \f[I]key\f[R]
if escaped with a backslash \f[B]\[rs]\f[R].
You may escape a normal \f[B]space\f[R] for use in your \f[I]key
chords\f[R], but when you hit \f[B]space\f[R] it will be recognized as a
\f[I]special key\f[R] and will fail to match the \f[B]space\f[R]
\f[I]key\f[R] in your \f[I]key chords\f[R].
.PP
In short, please use the special forms listed above to ensure the
corresponding keypress events trigger the desired \f[I]key chord\f[R].
.SS MODIFIER
A \f[I]modifier\f[R] is a prefix that can be added before any other
\f[I]modifier\f[R], \f[I]key\f[R], or \f[I]special key\f[R] to specify
the matching keypress.
It consists of a single letter (\f[B]C\f[R], \f[B]H\f[R], \f[B]M\f[R],
or \f[B]S\f[R]) followed by a hyphen \f[B]-\f[R].
The modifiers represent the following:
.RS
.TP
\f[B]C-\f[R]
\f[I]Control\f[R] key
.TP
\f[B]H-\f[R]
\f[I]Hyper\f[R] key
.TP
\f[B]M-\f[R]
\f[I]Meta\f[R] key
.TP
\f[B]S-\f[R]
\f[I]Shift\f[R] key
.RE
.PP
\f[B]NOTE\f[R] that a \f[I]modifier\f[R] can be given more than once
according to the grammar, but there is no practical benefit to this.
Additionally, the \f[B]S-\f[R] (\f[I]Shift\f[R]) \f[I]modifier\f[R] will
be ignored for all non \f[I]special keys\f[R].
You can define a \f[I]key\f[R] like \f[B]S-x\f[R], but when you press
\f[B]Shift+x\f[R], \f[B]wk\f[R] will only match the \f[I]key\f[R]
defined as \f[B]X\f[R].
.SS DESCRIPTION
A \f[I]description\f[R] provides a human-readable explanation or label
for a \f[I]key chord\f[R].
It is enclosed in double quotes \f[B]\[dq]\f[R].
If a double quote needs to be included within the \f[I]description\f[R],
it must be escaped with a backslash.
.PP
An \f[I]interpolation\f[R] may be used with a \f[I]description\f[R] as
well.
See \f[B]INTERPOLATION\f[R] below for a full explanation.
.SS COMMAND
A \f[I]command\f[R] represents the action or functionality triggered by
a \f[I]chord\f[R].
It is enclosed in \f[B]%{{\f[R] and \f[B]}}\f[R] delimiters.
The content within the delimiters can be any valid shell
\f[I]command\f[R] just as you would supply it at the command-line.
.PP
An \f[I]interpolation\f[R] may be used with a \f[I]command\f[R].
See \f[B]INTERPOLATION\f[R] below for a full explanation.
.PP
\f[B]NOTE\f[R] any \f[I]command\f[R] given to the \f[I]sync-before\f[R],
or \f[I]sync-after\f[R] \f[I]hooks\f[R] will be run in a blocking
manner.
Additionally, if the \f[I]sync-command\f[R] \f[I]flag\f[R] is given, the
the current \f[I]chord\f[R]\[aq]s \f[I]command\f[R] becomes blocking.
Depending on the \f[I]command\f[R] \f[B]wk\f[R] may never regain
control.
This is a serious concern as \f[B]wk\f[R] only releases the keyboard
after it has completed or encountered an error.
This could leave the user with an unresponsive keyboard until they
restart their system.
Think carefully before using a \f[I]command\f[R] in a blocking fashion.
.SS INTERPOLATION
An \f[I]interpolation\f[R] works the same way in \f[B]wks\f[R] as it
does in many programming languages.
An \f[I]interpolation\f[R] may be given within a \f[I]description\f[R]
or a \f[I]command\f[R], except where otherwise noted.
An \f[I]interpolation\f[R] begins with the \f[B]%(\f[R] delimiter and
ends with a closing parentheses \f[B])\f[R].
Within these delimiters, a single identifier must be given.
.SS IDENTIFIER
The following identifiers are valid within an \f[I]interpolation\f[R]:
.RS
.TP
\f[B]key\f[R]
The \f[I]key\f[R] \f[I]identifier\f[R] corresponds to the \f[I]key\f[R]
of the current \f[I]chord\f[R].
This makes the most sense to use within a \f[I]chord array\f[R] or for a
\f[I]chord\f[R] that may change frequently or is not know ahead of time.
.TP
\f[B]index\f[R]
The \f[I]index\f[R] \f[I]identifier\f[R] corresponds to the 0 base index
of the current \f[I]chord\f[R] or \f[I]prefix\f[R] within the current
scope.
\f[B]NOTE\f[R] a \f[I]prefix\f[R] starts a new scope.
.TP
\f[B]index+1\f[R]
The \f[I]index+1\f[R] \f[I]identifier\f[R] corresponds to the 1 base
index of the current \f[I]chord\f[R] or \f[I]prefix\f[R] within the
current scope.
\f[B]NOTE\f[R] a \f[I]prefix\f[R] starts a new scope.
.TP
\f[B]desc\f[R] and \f[B]description\f[R]
The \f[I]desc\f[R] and \f[I]description\f[R] \f[I]identifiers\f[R]
correspond to the \f[I]description\f[R] of the current \f[I]chord\f[R]
or \f[I]prefix\f[R].
Neither \f[I]identifier\f[R] may not be given within a
\f[I]description\f[R].
An error will be thrown in the case where this is attempted.
.RE
.SS KEYWORD
A \f[I]keyword\f[R] is an optional instruction to modify the behavior of
a \f[I]chord\f[R] or \f[I]prefix\f[R].
The \f[I]keywords\f[R] include \f[B]HOOKS\f[R], \f[B]FLAGS\f[R], and
\f[B]PREPROCESSOR COMMANDS\f[R].
See below for details.
.SS HOOK
A \f[I]hook\f[R] is a convenient way to add a \f[I]command\f[R] to a
\f[I]chord\f[R].
A \f[I]hook\f[R] may be given after a \f[I]description\f[R] starting
with a caret *^*^, followed by a \f[I]hook\f[R] and a \f[I]command\f[R].
If multiple of the same \f[I]hooks\f[R] are given to a \f[I]key
chord\f[R] the final instance will overshadow the others.
The \f[I]hook\f[R] \f[I]command\f[R] is executed in accordance with the
specification for the type of \f[I]hook\f[R].
.PP
The following are valid \f[I]hooks\f[R]:
.RS
.TP
\f[B]before\f[R] \f[I]command\f[R]
The \f[I]command\f[R] given to the \f[I]before\f[R] \f[I]hook\f[R] is
executed before the current \f[I]chord\f[R]\[aq]s \f[I]command\f[R], as
the name implies.
The \f[I]before\f[R] \f[I]command\f[R] is run asynchronously, meaning
the \f[I]chord\f[R]\[aq]s \f[I]command\f[R] may complete before the
\f[I]before\f[R] \f[I]command\f[R] has completed execution.
If you need the \f[I]chord\f[R]\[aq]s \f[I]command\f[R] to be run in
sync with the \f[I]before\f[R] \f[I]command\f[R], consider if there is
some other way to achieve this before using the \f[I]sync-before\f[R]
\f[I]hook\f[R].
.TP
\f[B]after\f[R] \f[I]command\f[R]
The \f[I]command\f[R] given to the \f[I]after\f[R] \f[I]hook\f[R] is
executed after the current \f[I]chord\f[R]\[aq]s \f[I]command\f[R], as
the name implies.
The \f[I]after\f[R] \f[I]command\f[R] is run asynchronously, meaning
\f[B]wk\f[R] will not wait for the command to complete before resuming
execution.
I \f[B]wk\f[R] should wait until the \f[I]after\f[R] \f[I]command\f[R]
completes you can use the \f[I]sync-after\f[R] \f[I]hook\f[R].
Just be certain you understand the pitfalls this introduces before you
use that \f[I]hook\f[R].
.TP
\f[B]sync-before\f[R] \f[I]command\f[R]
The \f[I]command\f[R] given to the \f[I]sync-before\f[R] \f[I]hook\f[R]
is executed before the current \f[I]chord\f[R]\[aq]s \f[I]command\f[R],
as the name implies.
Additionally, it is run in a blocking fashion, meaning \f[B]wk\f[R] will
not resume control until after the command completes or is terminated.
See the \f[B]COMMAND\f[R] section for best practices regarding blocking
\f[I]commands\f[R].
.TP
\f[B]sync-after\f[R] \f[I]command\f[R]
The \f[I]command\f[R] given to the \f[I]sync-after\f[R] \f[I]hook\f[R]
is executed after the current \f[I]chord\f[R]\[aq]s \f[I]command\f[R],
as the name implies.
Additionally, it is run in a blocking fashion, meaning \f[B]wk\f[R] will
not resume control until after the command completes or is terminated.
See the \f[B]COMMAND\f[R] section for best practices regarding blocking
\f[I]commands\f[R].
.RE
.PP
See \f[B]INHERITENCE\f[R] for an explanation of how \f[I]hooks\f[R] work
when given to a \f[I]prefix\f[R].
.PP
See \f[B]EXAMPLES\f[R] for a demonstration on \f[I]hooks\f[R].
.SS FLAG
A \f[I]flag\f[R] is a convenient way to modify the behavior of a
\f[I]key chord\f[R].
A \f[I]flag\f[R] may be passed after a \f[I]description\f[R] begining
with the plus character \f[B]+\f[R].
After the \f[B]+\f[R], a \f[I]flag\f[R] name is specified.
.PP
The following are \f[I]flag\f[R] names and how they affect the behavior
of \f[B]wk\f[R]:
.RS
.TP
\f[B]keep\f[R]
Normally, after executing a \f[I]chord\f[R], \f[B]wk\f[R] will close.
By supplying the \f[I]keep\f[R] flag, \f[B]wk\f[R] will persist after
the the \f[I]key chord\f[R] is trigger.
This enables you to trigger additional \f[I]key chords\f[R] until a
triggered \f[I]key chord\f[R] does not supply the \f[I]keep\f[R]
\f[I]flag\f[R] or no \f[I]key chords\f[R] match the keypress event.
.TP
\f[B]close\f[R]
The \f[I]close\f[R] \f[I]flag\f[R] is the default behavior for any
\f[I]chord\f[R].
However, a \f[I]chord\f[R] may inherit the \f[I]keep\f[R] \f[I]flag\f[R]
from a surrounding \f[I]prefix\f[R].
When this new behavior is undesired specifying the \f[I]close\f[R]
\f[I]flag\f[R] will restore the default behavior and end the
\f[B]wk\f[R] program after the \f[I]chord\f[R] is triggerd.
.TP
\f[B]inherit\f[R]
The \f[I]inherit\f[R] \f[I]flag\f[R] is only relevant to a child
\f[I]prefix\f[R] that wants to \f[I]inherit\f[R] \f[I]flags\f[R] and
\f[I]hooks\f[R] from its parent \f[I]prefix\f[R].
Inheritance is not the norm, hence this \f[I]flag\f[R] must be given
explicitly.
.TP
\f[B]unhook\f[R]
The \f[I]unhook\f[R] \f[I]flag\f[R] causes a child \f[I]key chord\f[R]
to ignore all \f[I]flags\f[R] and \f[I]hooks\f[R] present in the parent
\f[I]prefix\f[R].
Additional \f[I]hooks\f[R] and \f[I]flags\f[R] may be given to the child
\f[I]key chord\f[R] will work as expected.
.TP
\f[B]no-before\f[R]
The \f[I]no-before\f[R] \f[I]flag\f[R] prevents a child \f[I]key
chord\f[R] from inheriting a \f[I]before\f[R] or \f[I]sync-before\f[R]
\f[I]hook\f[R] present in the parent \f[I]prefix\f[R].
Any \f[I]before\f[R] or \f[I]sync-before\f[R] \f[I]hooks\f[R] given to
the child \f[I]key chord\f[R] will take precedence over those that may
be inherited from a parent \f[I]prefix\f[R].
In this case, the \f[I]no-before\f[R] \f[I]flag\f[R] is redundant as the
parent \f[I]hooks\f[R] are overshadowed.
.TP
\f[B]no-after\f[R]
The \f[I]no-after\f[R] \f[I]flag\f[R] prevents a child \f[I]key
chord\f[R] from inheriting an \f[I]after\f[R] or \f[I]sync-after\f[R]
\f[I]hook\f[R] present in the parent \f[I]prefix\f[R].
Any \f[I]after\f[R] or \f[I]sync-after\f[R] \f[I]hooks\f[R] given to the
child \f[I]key chord\f[R] will take precedence over those that may be
inherited from a parent \f[I]prefix\f[R].
In this case, the \f[I]no-after\f[R] \f[I]flag\f[R] is redundant as the
parent \f[I]hooks\f[R] are overshadowed.
.TP
\f[B]write\f[R]
By default, \f[B]wk\f[R] will execute a \f[I]chord\f[R]\[aq]s
\f[I]command\f[R] as though it were a shell command.
When the \f[I]write\f[R] \f[I]flag\f[R] is passed, the \f[I]command\f[R]
of the affected \f[I]chord\f[R] is simply written to the standard
output.
See \f[B]EXAMPLES\f[R] bleow if the effect is unclear.
.TP
\f[B]sync-command\f[R]
By default, \f[B]wk\f[R] will execute a \f[I]chord\f[R]\[aq]s
\f[I]command\f[R] asynchronously.
This means \f[B]wk\f[R] will continue execution despite the state of the
\f[I]command\f[R].
If, for some reason, a \f[I]chord\f[R]\[aq]s \f[I]command\f[R] should
block \f[B]wk\f[R] from continuing until the \f[I]command\f[R] ends,
then you can supply the \f[I]sync-command\f[R] \f[I]flag\f[R].
See \f[B]COMMAND\f[R] above to understand the pitfalls of blocking
\f[I]commands\f[R] in \f[B]wk\f[R].
.RE
.PP
See \f[B]INHERITENCE\f[R] for an explanation of how \f[I]flags\f[R] work
when given to a \f[I]prefix\f[R].
.PP
See \f[B]EXAMPLES\f[R] for a demonstration on \f[I]hooks\f[R].
.SS PREPROCESSOR MACROS
A \f[I]preprocessor macro\f[R] begins with a colon \f[B]:\f[R], followed
by a supported macro.
.PP
The following are the supported \f[I]preprocessor macros\f[R] and their
affects on \f[B]wks\f[R] files.
.RS
.TP
\f[B]include\f[R] \[dq]\f[I]FILEPATH\f[R]\[dq]
The \f[I]include\f[R] \f[I]preprocessor macro\f[R] acts in much the same
way as the \f[B]C\f[R] macro by the same name.
When the preprocessor spots an \f[I]include\f[R] macro it will replace
it with the contents of the given \f[I]file\f[R].
The \f[I]filepath\f[R] may be a relative or absolute \f[I]path\f[R] to
some \f[B]wks\f[R] \f[I]file\f[R].
If the \f[I]filepath\f[R] is relative it is assumed to be relative to
the \f[I]filepath\f[R] of the current \f[B]wks\f[R] \f[I]file\f[R] being
processed.
Absolute \f[I]filepaths\f[R] are just that and not very interesting.
One thing to note is that the \f[I]included\f[R] \f[I]file\f[R] will be
immediately loaded and then scanned by the preprocessor before the rest
of the original file is scanned.
This macro enables \f[B]wks\f[R] files to be quite modular as it can be
given \f[B]anywhere\f[R] inside a \f[B]wks\f[R] file.
This enables users to \f[I]include\f[R] a \f[B]wks\f[R] file that is not
valid when parsed on its own, but in the context of the
\f[I]including\f[R] \f[B]wks\f[R] file, it becomes valid.
The opposite is also true.
A perfectly valid \f[B]wks\f[R] file that \f[I]includes\f[R] an invalid
\f[B]wks\f[R] file in such a way that it does not become valid, will
then itself become invalid.
One bad apple and all that.
See \f[B]EXAMPLES\f[R] for a demonstration.
.RE
.SH AUTHORS
3L0C.
